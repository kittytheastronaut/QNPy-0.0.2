<!DOCTYPE html>
<html class="writer-html5" lang="en">
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.18.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Welcome to QNPy’s documentation! &mdash; QNPy 0.0.2 documentation</title>
      <link rel="stylesheet" type="text/css" href="_static/pygments.css" />
      <link rel="stylesheet" type="text/css" href="_static/css/theme.css" />

  
  <!--[if lt IE 9]>
    <script src="_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
        <script src="_static/jquery.js"></script>
        <script src="_static/underscore.js"></script>
        <script src="_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script src="_static/doctools.js"></script>
    <script src="_static/js/theme.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="#" class="icon icon-home">
            QNPy
              <img src="_static/logo.png" class="logo" alt="Logo"/>
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <!-- Local TOC -->
              <div class="local-toc"><ul>
<li><a class="reference internal" href="#">Welcome to QNPy’s documentation!</a></li>
<li><a class="reference internal" href="#qnpy-documentation">QNPy Documentation</a></li>
<li><a class="reference internal" href="#introduction">Introduction</a><ul>
<li><a class="reference internal" href="#conditional-neural-processes">Conditional Neural Processes</a></li>
<li><a class="reference internal" href="#self-organizing-maps">Self Organizing Maps</a></li>
</ul>
</li>
<li><a class="reference internal" href="#installation">Installation</a><ul>
<li><a class="reference internal" href="#requirements">Requirements</a></li>
</ul>
</li>
<li><a class="reference internal" href="#examples">Examples</a></li>
<li><a class="reference internal" href="#folder-structure">Folder Structure</a></li>
<li><a class="reference internal" href="#modules-and-their-functions">Modules and Their Functions</a></li>
<li><a class="reference internal" href="#frequently-asked-questions">Frequently Asked Questions</a></li>
<li><a class="reference internal" href="#licence">Licence</a></li>
<li><a class="reference internal" href="#sphinx-documentation">SPHINX_DOCUMENTATION</a></li>
<li><a class="reference internal" href="#qnpy-package">QNPy package</a><ul>
<li><a class="reference internal" href="#submodules">Submodules</a></li>
<li><a class="reference internal" href="#module-QNPy.CNP_ARCHITECTURE">QNPy.CNP_ARCHITECTURE module</a></li>
<li><a class="reference internal" href="#module-QNPy.CNP_DATASETCLASS">QNPy.CNP_DATASETCLASS module</a></li>
<li><a class="reference internal" href="#module-QNPy.CNP_METRICS">QNPy.CNP_METRICS module</a></li>
<li><a class="reference internal" href="#module-QNPy.Clustering_with_SOM">QNPy.Clustering_with_SOM module</a></li>
<li><a class="reference internal" href="#module-QNPy.PREDICTION">QNPy.PREDICTION module</a></li>
<li><a class="reference internal" href="#module-QNPy.PREDICTION_Original_mjd">QNPy.PREDICTION_Original_mjd module</a></li>
<li><a class="reference internal" href="#module-QNPy.PREDICTION_onePDF">QNPy.PREDICTION_onePDF module</a></li>
<li><a class="reference internal" href="#module-QNPy.PREDICTION_onePDF_original_mjd">QNPy.PREDICTION_onePDF_original_mjd module</a></li>
<li><a class="reference internal" href="#module-QNPy.Preprocess">QNPy.Preprocess module</a></li>
<li><a class="reference internal" href="#module-QNPy.SPLITTING_AND_TRAINING">QNPy.SPLITTING_AND_TRAINING module</a></li>
<li><a class="reference internal" href="#module-QNPy">Module contents</a></li>
</ul>
</li>
<li><a class="reference internal" href="#indices-and-tables">Indices and tables</a></li>
</ul>
</div>
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="#">QNPy</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="#" class="icon icon-home" aria-label="Home"></a></li>
      <li class="breadcrumb-item active">Welcome to QNPy’s documentation!</li>
      <li class="wy-breadcrumbs-aside">
            <a href="_sources/index.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="welcome-to-qnpy-s-documentation">
<h1>Welcome to QNPy’s documentation!<a class="headerlink" href="#welcome-to-qnpy-s-documentation" title="Permalink to this heading"></a></h1>
</section>
<section id="qnpy-documentation">
<h1>QNPy Documentation<a class="headerlink" href="#qnpy-documentation" title="Permalink to this heading"></a></h1>
</section>
<section id="introduction">
<h1>Introduction<a class="headerlink" href="#introduction" title="Permalink to this heading"></a></h1>
<p>In exploring the diverse features of quasar light curves, a significant challenge arises from recurring gaps in observations, which pose a primary limitation. This obstacle, compounded by the inherent irregularities in data collection cadences, presents a formidable barrier. This complexity will be particularly pronounced when dealing with data that is going to come from the Legacy Survey of Space and Time (LSST), featuring seasonal gaps. Existing strategies, while effective, entail substantial computational costs. To address the complex nature of quasar light curve modeling, our package QNPy has been developed to efficiently model quasar light curves using Conditional Neural Processes.</p>
<section id="conditional-neural-processes">
<h2>Conditional Neural Processes<a class="headerlink" href="#conditional-neural-processes" title="Permalink to this heading"></a></h2>
<p>Conditional Neural Processes (CNPs) are a type of neural network architecture designed for flexible and probabilistic function learning. They are particularly well-suited for tasks involving conditional predictions and have applications in areas like regression, classification, and generative modeling.</p>
<p>The core idea behind CNPs is to learn a distribution over functions conditioned on input-output pairs. They are capable of making predictions not only for specific inputs seen during training but also for new inputs that were not present in the training data.</p>
<p>The CNP is a model designed for analyzing continuous-time light curves, characterized by time instances (x) and corresponding fluxes (or magnitudes) (y). In the CNP framework, we consider a scenario where we have target inputs representing time instances with unknown magnitudes. In the training process, we leverage a set of context points derived from observations, consisting of time instances (x) and observed magnitudes (y). Each pair in the context set is locally encoded using a multilayer perceptron (MLP). The resulting local encodings (Rc) are then aggregated through mean pooling to form a global representation (R). The global representation (R) is a condensed feature representation of the entire context set. This representation, along with the target input (xt), is fed into a decoder MLP. The decoder produces the mean and variance of the predictive distribution for the target output.</p>
<img alt="descriptive text for image" class="align-left" src="_images/CNP.png" />
<p>Key features of Conditional Neural Processes include:</p>
<ol class="arabic simple">
<li><p><strong>Conditional Predictions</strong>: CNPs can provide predictions for a target output given a set of input-output pairs, allowing for context-aware predictions.</p></li>
<li><p><strong>Flexibility</strong>: CNPs are versatile and can adapt to various types of data and tasks. They are not limited to a specific functional form, making them suitable for a wide range of applications.</p></li>
<li><p><strong>Probabilistic Outputs</strong>: CNPs provide uncertainty estimates in the form of predictive distributions. This makes them valuable in situations where uncertainty quantification is crucial.</p></li>
<li><p><strong>Scalability</strong>: CNPs can handle different input and output dimensions, making them scalable to various data types and problem complexities.</p></li>
</ol>
<p>In summary, Conditional Neural Processes are a powerful framework for conditional function learning that offers flexibility, probabilistic predictions, and scalability across different tasks. They have shown effectiveness in tasks such as few-shot learning, meta-learning, and regression with uncertainty estimation, making them a great tool for modeling the light curves of quasars.</p>
</section>
<section id="self-organizing-maps">
<h2>Self Organizing Maps<a class="headerlink" href="#self-organizing-maps" title="Permalink to this heading"></a></h2>
<p>Conditional Neural Processes excel at learning complex patterns in data with recurring gaps. However, application to larger datasets requires novel methods to prioritize efficiency and effectively capture subtle trends in the data. Self Organizing Maps (SOMs) provide both these advantages. SOMs provide an unsupervised clustering algorithm that can be trained quickly and include new data points without the need to train over every data point again. Thus, we present QNPy as an ensemble model of SOMs and CNPs.</p>
<p>SOMs comprise a network of nodes mapped onto a (usually) two-dimensional grid. Each node has an input weight associated with it. As the SOM trains on the input data, each input point is assigned a Best Matching Unit (BMU) where the node is at the minimum Euclidean distance from the input. Then, the BMU is updated to match the input data point (the amount that the node moves is dependent on the learning rate). Furthermore, each node can affect neighboring nodes via a neighborhood function (usually Gaussian).</p>
<p>Once the training is ended, each input data point is assigned to a cluster depending on the final BMU. Thus at the end, each node provides a cluster. These can be the final cluster or the distance matrix (a matrix containing the distance of each node with each of the other nodes) of the SOM can be used to group different nodes into more hierarchical clusters. This is done by calculating gradients between the nodes until the lowest node is reached. (For more info, refer to [Hamel and Brown](<a class="reference external" href="https://homepage.cs.uri.edu/faculty/hamel/pubs/improved-umat-dmin11.pdf">https://homepage.cs.uri.edu/faculty/hamel/pubs/improved-umat-dmin11.pdf</a>)).</p>
<p>In QNPy, we treat each light curve as a data point and the magnitudes are the features. Thus, the SOM can effectively parse topological differences in the light curves. These differences allow the CNP to train on similar light curves and effectively capture subtle differences in the modeled light curves. In addition, the clusters now allow for CNPs to be trained in parallel on smaller batches of data, which allows for a massive speed-up in the training time of the QNPy package.</p>
<p>The SOM is based on the [minisom package](<a class="reference external" href="https://github.com/JustGlowing/minisom">https://github.com/JustGlowing/minisom</a>) which uses NumPy packages to handle the input data. Thus, every input data point must have the same length. We handle this similarly with the CNP by padding all the light curves to the same length. We also scale the light curves to treat different magnitude ranges differently.</p>
<p>Thus, SOMs provide a useful companion to the CNPs to form an ensemble model with improved speed and accuracy in modeling large amounts of light curve data.</p>
</section>
</section>
<section id="installation">
<h1>Installation<a class="headerlink" href="#installation" title="Permalink to this heading"></a></h1>
<p>To install QNPy, use the following command:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>pip<span class="w"> </span>install<span class="w"> </span>QNPy
</pre></div>
</div>
<section id="requirements">
<h2>Requirements<a class="headerlink" href="#requirements" title="Permalink to this heading"></a></h2>
<p>This package contains a <cite>requirements.txt</cite> file with all the dependencies that need to be satisfied before you can use it as a standalone package. To install all requirements at once, navigate to the directory where you downloaded your package (where the <cite>requirements.txt</cite> file is) and run:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>pip<span class="w"> </span>install<span class="w"> </span>-r<span class="w"> </span>requirements.txt
</pre></div>
</div>
<p>You are now ready to use the QNPy package.</p>
<p>Special note: If you have python &gt;3.9 on your local machine you will encounter some requirements conflicts with torch and numpy versions. In this case, we recomend creating a virtual enviroment using conda:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>conda<span class="w"> </span>create<span class="w"> </span>-n<span class="w"> </span>myenv<span class="w"> </span><span class="nv">python</span><span class="o">=</span><span class="m">3</span>.9
</pre></div>
</div>
<p>then you have to activate the virtuel enviroment:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>conda<span class="w"> </span>activate<span class="w"> </span><span class="s2">&quot;The name of your virtuel enviroment&quot;</span>
</pre></div>
</div>
<p>After virtual enviroment is activated you can install QNPy and the requirements.txt file in your newly created enviroment.</p>
</section>
</section>
<section id="examples">
<h1>Examples<a class="headerlink" href="#examples" title="Permalink to this heading"></a></h1>
<p>Check out the <cite>Tutorial</cite> folder [here](<a class="reference external" href="https://github.com/kittytheastronaut/QNPy-0.0.2">https://github.com/kittytheastronaut/QNPy-0.0.2</a>) for notebooks that guide you through the process of using this package. There will be teo tutorial folders. The “QNPy without clustering: Tutorial” folder includes examples for using each of the modules separately. Additionally, you’ll find an example of how your light curves should look in the <cite>Light_curves</cite> folder. The “QNPy with clustering: Tutorial” folder includes examples for using the Clustering_with_SOM module for single band and multiband clustering. You will also find example of how your light curves should look like in the folders <cite>Light_curves</cite> and <cite>Light_curves_Multiband</cite>.</p>
</section>
<section id="folder-structure">
<h1>Folder Structure<a class="headerlink" href="#folder-structure" title="Permalink to this heading"></a></h1>
<p>The QNPy automatically creates folders for saving plots, data and saves your trained SOM and CNP. The only requirement for the file structure in SOM module is to save light curves before the module and choose directories to save plots and models during the module’s runtime. The files can be saved under any folder as desired and the file name can be given as an input into the loading function.</p>
<p>In the case of multi-band light curves only, the light curves should be saved under a directory (can be named anything) with the filters saved as subfolders. Then, each light curve should be saved as a CSV file with the id as the file name. For example, if you have a light curve in the g filter with ID 10422 and you want to save it in a folder known as <cite>Light_Curves</cite>, it should be saved under the directory <cite>Light_Curves/g/10422.csv</cite>. This is the standard recommendation for multi-band data. Then, once the clusters are created, it is easy to either point QNPy to one of the filters of a cluster or to manually flatten the file and provide all the light curves to QNPy. However, QNPy does not yet support explicit multi-band clustering.</p>
<p>For all QNPy modules, your data must contain: <cite>mjd</cite> - MJD or time, <cite>mag</cite> - magnitude, and <cite>magerr</cite> - magnitude error.</p>
<p>Before running the script, you can manually create the following folders in the directory where your Python notebook is located:</p>
<ol class="arabic simple">
<li><p><cite>./preproc/</cite> - for saving the transformed data</p></li>
<li><p><cite>./padded_lc/</cite> - for saving the padded light curves</p></li>
<li><p><cite>./dataset/train/</cite>, <cite>./dataset/test/</cite>, <cite>./dataset/val/</cite> - for organizing your dataset</p></li>
<li><p><cite>./output/prediction/test/data/</cite>, <cite>./output/prediction/test/plots/</cite> - for organizing prediction results</p></li>
<li><p><cite>./output/prediction/train/data/</cite>, <cite>./output/prediction/train/plots/</cite> - for organizing training results</p></li>
<li><p><cite>./output/prediction/val/data/</cite>, <cite>./output/prediction/val/plots/</cite> - for organizing validation results</p></li>
</ol>
</section>
<section id="modules-and-their-functions">
<h1>Modules and Their Functions<a class="headerlink" href="#modules-and-their-functions" title="Permalink to this heading"></a></h1>
<blockquote>
<div><p><strong>Clustering with SOM</strong></p>
<blockquote>
<div><p><strong>`Clustering_with_SOM.py`</strong></p>
<p>In the clustering module, we first load the light curves from the directory. This also creates the ids from the file names. Thus, it is recommended to have the same light curves saved across all the different bands. Then, we pad the light curves to make them all the same length. In QNPy, we have seen that we require at least 100 data points for accurate modeling. Thus, we recommend that the light curves be padded to at least 100 points (even if the longest curve is under 100 points, which can be controlled through a keyword in the padding function). Finally, we scale the light curves. We have provided many different scalers including minmax, standard and robust scalers. Our <cite>default</cite> scaler is an adapted version of a minmax scaler that scales all the data to the range [-2,2].</p>
<p>Then, a SOM is trained on the scaled data. The SOM contains different tunable hyperparameters to better adapt to different data sets. These hyperparameters can be tested with different metrics including quantization error, topographical error, silhouette score, davies-bouldin index, or calinski-harabasz score. The trained SOM can be saved as well.</p>
<p>The trained SOM is then used to assign the IDs to different clusters. Then they can be saved into different folders.</p>
<p>We also provide different plots for visualization of the data. These will be described in the plotting functions.</p>
<p>Described below are the functions used in the module:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">Plot_Lc</span><span class="p">(</span><span class="n">Light_Curve</span><span class="p">,</span><span class="n">header</span> <span class="o">=</span> <span class="s1">&#39;Light Curve&#39;</span><span class="p">,</span><span class="n">save_fig</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span><span class="n">filename</span> <span class="o">=</span> <span class="s1">&#39;Figure&#39;</span><span class="p">,</span><span class="n">x_axis</span> <span class="o">=</span> <span class="s1">&#39;mjd&#39;</span><span class="p">,</span><span class="n">return_fig</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Plots light curves interactively. Adapted from https://github.com/DamirBogdan39/time-series-analysis/tree/main</span>

<span class="sd">    Parameters</span>
<span class="sd"> ----------</span>
<span class="sd"> Light_Curve: Dataframe</span>
<span class="sd"> The light curve to plot. Should be in a dataframe with mjd (or any x axis), mag and magerr</span>

<span class="sd">    header: str</span>
<span class="sd">    The header of the file</span>

<span class="sd">    save_fig: bool</span>
<span class="sd">    Whether to save the figure</span>

<span class="sd">    filename: str</span>
<span class="sd">    What to name the saved html file</span>

<span class="sd">    x_axis: str</span>
<span class="sd">    What to label the x axis</span>

<span class="sd">    return_fig: bool</span>
<span class="sd">    Whether the figure is returned</span>

<span class="sd">    Returns</span>
<span class="sd">    --------</span>
<span class="sd">    Figure:</span>
<span class="sd">    The interactive plot of the light curve</span>
<span class="sd">    &#39;&#39;&#39;</span>
</pre></div>
</div>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">Load_Light_Curves</span><span class="p">(</span><span class="n">folder</span><span class="p">,</span><span class="n">one_filter</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span><span class="n">filters</span> <span class="o">=</span> <span class="s1">&#39;a&#39;</span><span class="p">,</span><span class="n">id_list</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Loads light curves from a specified folder. Can be used to load either multiple filters or just one filter</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    folder: str</span>
<span class="sd">    The folder where the light curves are stored</span>

<span class="sd">    one_filter: bool</span>
<span class="sd">    If set to true, the light curves are only stored in one folder without filters</span>

<span class="sd">    filters: list or str(if each filter is a single letter)</span>
<span class="sd">    The filters that are to be loaded. Each filter should have a subfolder named after it if there are more than one filters</span>

<span class="sd">    id_list: list of str or None</span>
<span class="sd">    The subset of IDs to load. If None, retrieves all files in the given folder. NOTE: make sure the ids are strings</span>

<span class="sd">    Returns</span>
<span class="sd">    --------</span>
<span class="sd">    light_curves: list of lists of dataframes</span>
<span class="sd">    The list of light curves arranged by filter</span>

<span class="sd">    ids: list</span>
<span class="sd">    The ids of the light curves (Ensure that they are the same in all filters)</span>
<span class="sd">    &#39;&#39;&#39;</span>
</pre></div>
</div>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">Pad_Light_Curves</span><span class="p">(</span><span class="n">light_curves</span><span class="p">,</span><span class="n">minimum_length</span> <span class="o">=</span> <span class="mi">100</span><span class="p">,</span><span class="n">save_padded_lcs</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span><span class="n">padded_lcs_save_path</span> <span class="o">=</span> <span class="s1">&#39;./&#39;</span><span class="p">,</span><span class="n">ids</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Pads the light curves with the mean value at the end of the curve</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    light_curves: lists of dataframes</span>
<span class="sd">    The light curves stored in a list</span>

<span class="sd">    minimum_length: int</span>
<span class="sd">    The minimum length to pad to</span>

<span class="sd">    save_padded_lcs: bool</span>
<span class="sd">    If True, will save the light curves into a folder known as Padded_Lc in the specified directory</span>

<span class="sd">    padded_lcs_save_path: str</span>
<span class="sd">  The directory to save the light curves in</span>

<span class="sd">    ids: list of str</span>
<span class="sd">    A list of the ids. Must provided in order to save the light curves</span>

<span class="sd">    Returns</span>
<span class="sd">    --------</span>
<span class="sd">    light_curves: list of lists</span>
<span class="sd">    The new padded light curves</span>
<span class="sd">    &#39;&#39;&#39;</span>
</pre></div>
</div>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">scale_curves</span><span class="p">(</span><span class="n">light_curves</span><span class="p">,</span><span class="n">what_scaler</span> <span class="o">=</span> <span class="s1">&#39;default&#39;</span><span class="p">,</span><span class="n">scale_times</span> <span class="o">=</span> <span class="kc">True</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Scaling the curves (from a single filter) from the choice of minmax, standard and robust. By default, it scales to a range of [-2,2]</span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    light_curves: list of dataframes</span>
<span class="sd">    The light curves stored in a list.</span>

<span class="sd">  what_scaler: string</span>
<span class="sd">    The type of scaler to use. There are default (see above), standard scaler, min-max scaler and robust scalers available</span>

<span class="sd">    scale_times: bool</span>
<span class="sd">    Whether to scale the time axis as well (These are always scaled to the default scaler)</span>

<span class="sd">    Returns</span>
<span class="sd">    --------</span>
<span class="sd">    scaled_curves: np.ndarray</span>
<span class="sd">    The scaled light curves</span>

<span class="sd">    scaled_times:np.ndarray</span>
<span class="sd">    The scaled time steps. It is an empty list if the keyword scale_times is False</span>
<span class="sd">    &#39;&#39;&#39;</span>
</pre></div>
</div>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">SOM_1D</span><span class="p">(</span><span class="n">scaled_curves</span><span class="p">,</span><span class="n">som_x</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span><span class="n">som_y</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span><span class="n">learning_rate</span> <span class="o">=</span> <span class="mf">0.1</span><span class="p">,</span><span class="n">sigma</span> <span class="o">=</span> <span class="mf">1.0</span><span class="p">,</span><span class="n">topology</span> <span class="o">=</span> <span class="s1">&#39;rectangular&#39;</span><span class="p">,</span><span class="n">pca_init</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>\
<span class="n">neighborhood_function</span><span class="o">=</span><span class="s1">&#39;gaussian&#39;</span><span class="p">,</span><span class="n">train_mode</span> <span class="o">=</span> <span class="s1">&#39;random&#39;</span><span class="p">,</span><span class="n">batch_size</span> <span class="o">=</span> <span class="mi">5</span><span class="p">,</span><span class="n">epochs</span> <span class="o">=</span> <span class="mi">50000</span><span class="p">,</span><span class="n">save_som</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>\
<span class="n">model_save_path</span> <span class="o">=</span> <span class="s1">&#39;./&#39;</span><span class="p">,</span><span class="n">random_seed</span> <span class="o">=</span> <span class="mi">21</span><span class="p">,</span><span class="n">stat</span> <span class="o">=</span> <span class="s1">&#39;q&#39;</span><span class="p">,</span><span class="n">plot_frequency</span> <span class="o">=</span> <span class="mi">100</span><span class="p">,</span><span class="n">early_stopping_no</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Training a SOM on ONE dimensional data (The magnitude of the light curves)</span>
<span class="sd"> Parameters</span>
<span class="sd">  ----------</span>
<span class="sd"> scaled_curves: list of dataframes</span>
<span class="sd"> The scaled light curves stored in a list.</span>

<span class="sd"> som_x: int</span>
<span class="sd"> The x size of the SOM. If None is given, make sure the som_y is None as well. Then, it chooses the recommended SOM</span>
<span class="sd"> size of sqrt(sqrt(length))</span>

<span class="sd"> som_y: int</span>
<span class="sd"> The y size of the SOM. If None is given, make sure the som_x is None as well. Then, it chooses the recommended SOM</span>
<span class="sd"> size of sqrt(sqrt(length))</span>

<span class="sd"> learning_rate: float</span>
<span class="sd"> How much the SOM learns from the new data that it sees</span>

<span class="sd"> sigma: float</span>
<span class="sd"> The effect each node has on its neighboring nodes</span>

<span class="sd">    topology: &#39;rectangular&#39; or &#39;hexagonal&#39;:</span>
<span class="sd"> The topology of the SOM. Note that visualizations are mainly built for the rectangular at the moment.</span>

<span class="sd"> pca_init: bool</span>
<span class="sd">  Whether to initialize the SOM weights randomly or to initialize by PCA of the input data</span>

<span class="sd">  neighborhood_function: str</span>
<span class="sd">  Choose from &#39;gaussian&#39;,&#39;mexican hat&#39;,&#39;bubble&#39;, or &#39;triangle&#39;. These affect the influence of a node on its neighbors</span>

<span class="sd">  train_mode:&#39;random&#39; or &#39;all&#39;</span>
<span class="sd">  When chosen random, it chooses a random curve each epoch. When trained on all, it batches the data and trains on every</span>
<span class="sd">   light curve for a certain number of epochs.</span>

<span class="sd">   batch_size: int</span>
<span class="sd">   How big the batch is for the &#39;all&#39; train mode. The smaller the batch size, the finer the progress bar displayed</span>

<span class="sd">   epochs: int</span>
<span class="sd">  This is defined in two ways. If the train_mode is random, then it is the number of iterations that the SOM runs on.</span>
<span class="sd">  If it is all, then it is the number of times that the SOM trains on each input datapoint. Note that the lr and sigma</span>
<span class="sd">   decay in each epoch.</span>

<span class="sd">   save_som: bool</span>
<span class="sd">   Whether to save the trained SOM</span>

<span class="sd">   model_save_path:str</span>
<span class="sd">   The file to save the SOM in</span>

<span class="sd">   random_seed:int</span>
<span class="sd">   The starting state of the random weights of the SOM. Use for reproducibility</span>

<span class="sd">   stat: &#39;q&#39;,&#39;t&#39;, or &#39;qt&#39;</span>
<span class="sd">    Whether to record the quantization error,   topographical error or both. Note that calculating them is expensive</span>

<span class="sd"> plot_frequency: int</span>
<span class="sd">  The number of epochs</span>

<span class="sd">  early_stopping_no: int or None</span>
<span class="sd">  The number of batches to process before stopping. Use None if you should train on all</span>

<span class="sd"> Returns</span>
<span class="sd"> --------</span>
<span class="sd"> som_model:</span>
<span class="sd"> The trained SOM that can be saved or used for analysis</span>

<span class="sd"> q_error: list</span>
<span class="sd">  The quantization errors recorded</span>

<span class="sd">   t_error: list</span>
<span class="sd">   The topographic errors recorded</span>

<span class="sd">   indices_to_plot: list</span>
<span class="sd">   The indices to plot for the quantization or/and topographic errors</span>
<span class="sd">    &#39;&#39;&#39;</span>
</pre></div>
</div>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">plot_training</span><span class="p">(</span><span class="n">training_metric_results</span><span class="p">,</span><span class="n">metric</span><span class="p">,</span><span class="n">plotting_frequency</span><span class="p">,</span><span class="n">indices_to_plot</span><span class="p">,</span><span class="n">figsize</span> <span class="o">=</span> <span class="p">(</span><span class="mi">10</span><span class="p">,</span><span class="mi">10</span><span class="p">),</span><span class="n">save_figs</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span><span class="n">fig_save_path</span> <span class="o">=</span> <span class="s1">&#39;./&#39;</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd"> Plots the metric given (quantization error or topographic error)</span>

<span class="sd">  Parameters</span>
<span class="sd"> ----------</span>
<span class="sd"> training_metric_results: list</span>
<span class="sd"> The result obtained from the SOM training</span>

<span class="sd"> metric: str</span>
<span class="sd"> Name of the metric</span>

<span class="sd"> plotting_frequency: int</span>
<span class="sd">  How much was the plotting frequency set during the SOM training</span>

<span class="sd">  indices_to_plot: list</span>
<span class="sd">  The indices to plot obtained from the SOM training</span>

<span class="sd">  figsize: tuple</span>
<span class="sd">  The size of the figure</span>

<span class="sd">  save_figs: bool</span>
<span class="sd">  Whether to save the figure or not</span>

<span class="sd">  fig_save_path:str</span>
<span class="sd">  Where to save the figure. Note that it creates a directory called Plots in the location given.</span>

<span class="sd">  Returns</span>
<span class="sd">  --------</span>
<span class="sd">  Plot:</span>
<span class="sd">  The plot of the metric</span>
<span class="sd">  &#39;&#39;&#39;</span>
</pre></div>
</div>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">Plot_SOM_Scaled_Average</span><span class="p">(</span><span class="n">som_model</span><span class="p">,</span><span class="n">scaled_curves</span><span class="p">,</span><span class="n">dba</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span><span class="n">figsize</span> <span class="o">=</span> <span class="p">(</span><span class="mi">10</span><span class="p">,</span><span class="mi">10</span><span class="p">),</span><span class="n">save_figs</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span><span class="n">figs_save_path</span> <span class="o">=</span> <span class="s1">&#39;./&#39;</span><span class="p">,</span>\
<span class="n">plot_weights</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span><span class="n">plot_avg</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span><span class="n">plot_background</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span><span class="n">one_fig</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span><span class="n">show_fig</span> <span class="o">=</span> <span class="kc">True</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd"> Plotting the SOM Clusters with the average light curve and the SOM weights of each cluster. The average can be either simple mean</span>
<span class="sd"> or using a dba averaging method (https://github.com/fpetitjean/DBA)</span>

<span class="sd"> Parameters</span>
<span class="sd">  ----------</span>
<span class="sd"> som_model:</span>
<span class="sd">  The trained SOM</span>

<span class="sd"> scaled_curves: np.ndarray</span>
<span class="sd"> The scaled curves that were the input for training</span>

<span class="sd"> dba: bool</span>
<span class="sd"> Whether to use Dynamic Barymetric Time Averaging</span>

<span class="sd"> figsize: tuple</span>
<span class="sd"> The size of the figure</span>

<span class="sd"> save_figs: bool</span>
<span class="sd"> Whether to save the figure or not</span>

<span class="sd"> fig_save_path: str</span>
<span class="sd"> Where to save the figure. Note that it creates a directory called Plots in the location given.</span>

<span class="sd"> plot_avg: bool</span>
<span class="sd">  Whether to plot the mean light curve of the cluster</span>

<span class="sd">  plot_weights: bool</span>
<span class="sd">  Whether to plot the SOM weight of the cluster</span>

<span class="sd">  plot_background: bool</span>
<span class="sd">  Whether to plot the light curves that make up the cluster</span>

<span class="sd"> one_fig: bool</span>
<span class="sd">  Whether to plot all the clusters into one figure or seperate figures</span>

<span class="sd">  show_fig: bool</span>
<span class="sd">  Whether to show each of the plots in the seperate figures case</span>

<span class="sd"> Returns</span>
<span class="sd">  --------</span>
<span class="sd">   Plot:</span>
<span class="sd">   The plots of the clusters</span>
<span class="sd">    &#39;&#39;&#39;</span>
</pre></div>
</div>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">SOM_Distance_Map</span><span class="p">(</span><span class="n">som_model</span><span class="p">,</span><span class="n">figsize</span> <span class="o">=</span> <span class="p">(</span><span class="mi">5</span><span class="p">,</span><span class="mi">5</span><span class="p">),</span><span class="n">cmap</span> <span class="o">=</span> <span class="s1">&#39;YlOrRd&#39;</span><span class="p">,</span><span class="n">save_figs</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span><span class="n">figs_save_path</span> <span class="o">=</span> <span class="s1">&#39;./&#39;</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Plots a heatmap of the SOM Nodes. The brighter, the further away they are from their neighbors</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd"> som_model:</span>
<span class="sd"> The trained SOM</span>

<span class="sd">    cmap: str</span>
<span class="sd">    The matplotlib based color scale to use for the plots</span>

<span class="sd">    figsize: tuple</span>
<span class="sd"> The size of the figure</span>

<span class="sd">    save_figs: bool</span>
<span class="sd">    Whether to save the figure or not</span>

<span class="sd">    fig_save_path: str</span>
<span class="sd">    Where to save the figure. Note that it creates a directory called Plots in the location given.</span>

<span class="sd">    Returns</span>
<span class="sd">    --------</span>
<span class="sd">    Plot:</span>
<span class="sd">    The heatmap plot</span>
<span class="sd">    &#39;&#39;&#39;</span>
</pre></div>
</div>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">SOM_Activation_Map</span><span class="p">(</span><span class="n">som_model</span><span class="p">,</span><span class="n">figsize</span> <span class="o">=</span> <span class="p">(</span><span class="mi">5</span><span class="p">,</span><span class="mi">5</span><span class="p">),</span><span class="n">cmap</span> <span class="o">=</span> <span class="s1">&#39;YlOrRd&#39;</span><span class="p">,</span><span class="n">save_figs</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span><span class="n">figs_save_path</span> <span class="o">=</span> <span class="s1">&#39;./&#39;</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Plots a heatmap of the SOM Nodes. The brighter, the more light curves activate the SOM</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    som_model:</span>
<span class="sd">    The trained SOM</span>

<span class="sd">    cmap: str</span>
<span class="sd">    The matplotlib based color scale to use for the plots</span>

<span class="sd">    figsize: tuple</span>
<span class="sd">    The size of the figure</span>

<span class="sd">    save_figs: bool</span>
<span class="sd">    Whether to save the figure or not</span>

<span class="sd">    fig_save_path: str</span>
<span class="sd">  Where to save the figure. Note that it creates a directory called Plots in the location given.</span>

<span class="sd"> Returns</span>
<span class="sd"> --------</span>
<span class="sd">    Plot:</span>
<span class="sd"> The heatmap plot</span>
<span class="sd">    &#39;&#39;&#39;</span>
</pre></div>
</div>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">Assign_Cluster_Labels</span><span class="p">(</span><span class="n">som_model</span><span class="p">,</span><span class="n">scaled_curves</span><span class="p">,</span><span class="n">ids</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd"> Assigns Cluster labels to each of the curves, making a dataframe with their ids</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    som_model:</span>
<span class="sd"> The trained SOM</span>

<span class="sd">    scaled_curves: np.ndarray</span>
<span class="sd">    The scaled curves that were used to train the SOM</span>

<span class="sd">    ids: list</span>
<span class="sd"> The ids of the curves</span>

<span class="sd">    Returns</span>
<span class="sd">    --------</span>
<span class="sd"> cluster_df: Dataframe</span>
<span class="sd"> A map matching each of the cluster ids with the cluster they belong to</span>
<span class="sd">    &#39;&#39;&#39;</span>
</pre></div>
</div>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">SOM_Clusters_Histogram</span><span class="p">(</span><span class="n">cluster_map</span><span class="p">,</span><span class="n">color</span> <span class="o">=</span> <span class="s1">&#39;tab:blue&#39;</span><span class="p">,</span><span class="n">save_figs</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span><span class="n">figs_save_path</span> <span class="o">=</span> <span class="s1">&#39;./&#39;</span><span class="p">,</span><span class="n">figsize</span> <span class="o">=</span> <span class="p">(</span><span class="mi">5</span><span class="p">,</span><span class="mi">5</span><span class="p">)):</span>
<span class="w"> </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Plots a heatmap of the SOM Nodes. The brighter, the further away they are from their neighbors</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    cluster_map:</span>
<span class="sd">    The dataframe with each id and the cluster that it belongs to</span>

<span class="sd">    color: str</span>
<span class="sd">    The color to plot the histogram</span>

<span class="sd"> save_figs: bool</span>
<span class="sd"> Whether to save the figure or not</span>

<span class="sd"> fig_save_path: str</span>
<span class="sd"> Where to save the figure. Note that it creates a directory called Plots in the location given.</span>

<span class="sd">    figsize: tuple</span>
<span class="sd"> The size of the figure</span>

<span class="sd"> Returns</span>
<span class="sd"> --------</span>
<span class="sd"> Plot:</span>
<span class="sd">    The Histogram of how many curves are in each cluster</span>
<span class="sd"> &#39;&#39;&#39;</span>
</pre></div>
</div>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">findMin</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">umat</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Finds the minimum node in the unified matrix when given the x and y coordinate</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x: int</span>
<span class="sd">    The x position of the given input node</span>

<span class="sd">    y: int</span>
<span class="sd">    The y position of the given input node</span>

<span class="sd">    umat: np.ndarry</span>
<span class="sd">    The unified distance matrix of the nodes of the SOM</span>

<span class="sd">    Returns</span>
<span class="sd"> --------</span>
<span class="sd"> minx, miny:</span>
<span class="sd"> The minumum x node and minimum y node</span>
<span class="sd">    &#39;&#39;&#39;</span>
</pre></div>
</div>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">findInternalNode</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">umat</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd"> Finds the minimum node in the unified matrix when given the x and y coordinate, taking into account if the current node is min</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd"> x: int</span>
<span class="sd">    The x position of the given input node</span>

<span class="sd">    y: int</span>
<span class="sd"> The y position of the given input node</span>

<span class="sd">    umat: np.ndarry</span>
<span class="sd">    The unified distance matrix of the nodes of the SOM</span>

<span class="sd">    Returns</span>
<span class="sd">    --------</span>
<span class="sd"> minx, miny:</span>
<span class="sd"> The minumum x node and minimum y node</span>
<span class="sd">    &#39;&#39;&#39;</span>
</pre></div>
</div>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">Get_Gradient_Cluster</span><span class="p">(</span><span class="n">som</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Finds the center of the gradient for each node of the SOM</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    som: int</span>
<span class="sd">    The trained SOM</span>

<span class="sd">    Returns</span>
<span class="sd">    --------</span>
<span class="sd">    cluster_centers:</span>
<span class="sd">    The center nodes that become the new gradient clusters</span>

<span class="sd">    cluster_pos:</span>
<span class="sd">    The original SOM cluster centers</span>
<span class="sd">    &#39;&#39;&#39;</span>
</pre></div>
</div>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">Normal_Cluster_to_Grad</span><span class="p">(</span><span class="n">cluster_map</span><span class="p">,</span><span class="n">gradient_cluster_map</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Maps the normal cluster map to the gradient clusters</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    cluster_map: pd.DataFrame</span>
<span class="sd">    The map of the ids to the original SOM node clusters</span>

<span class="sd">    gradient_cluster_map: pd.DataFrame</span>
<span class="sd">    The map of the ids to the gradient SOM node clusters</span>

<span class="sd">    Returns</span>
<span class="sd">    --------</span>
<span class="sd">    joint_map:</span>
<span class="sd">    Mapping of each SOM node cluster to the gradient cluster</span>
<span class="sd">    &#39;&#39;&#39;</span>
</pre></div>
</div>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">Gradient_Cluster_Map</span><span class="p">(</span><span class="n">som</span><span class="p">,</span><span class="n">scaled_curves</span><span class="p">,</span><span class="n">ids</span><span class="p">,</span><span class="n">dimension</span> <span class="o">=</span> <span class="s1">&#39;1D&#39;</span><span class="p">,</span><span class="n">fill</span> <span class="o">=</span> <span class="s1">&#39;mean&#39;</span><span class="p">,</span><span class="n">interpolation_kind</span> <span class="o">=</span> <span class="s1">&#39;cubic&#39;</span><span class="p">,</span><span class="n">clusters</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span><span class="n">som_x</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span><span class="n">som_y</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Translates the SOM nodes into larger clusters based on their gradients. Implementation of</span>
<span class="sd">    https://homepage.cs.uri.edu/faculty/hamel/pubs/improved-umat-dmin11.pdf</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    som_model:</span>
<span class="sd">    The trained SOM</span>

<span class="sd">    scaled_curves: np.ndarray</span>
<span class="sd">    The scaled curves used to train the SOM</span>

<span class="sd">    ids: list</span>
<span class="sd">    The ids of the curves</span>

<span class="sd">    dimension: str</span>
<span class="sd">    If 1D, does 1D clustering, else multivariate</span>

<span class="sd">    fill: str</span>
<span class="sd">    &#39;mean&#39; or &#39;interpolate&#39;. Either the empty values are filled with the mean or they are interpolated with a function</span>

<span class="sd">    interpolation_kind:</span>
<span class="sd">    Any of the scipy.interp1d interpolation kinds. Recommended to use cubic</span>

<span class="sd">    clusters:</span>
<span class="sd">    The clusters that the ids are in (only for multi-variate)</span>

<span class="sd">    som_x: int</span>
<span class="sd">    The x-dimensions of the SOM</span>

<span class="sd">    som_y: int</span>
<span class="sd">    The y-dimensions of the SOM</span>

<span class="sd">    Returns</span>
<span class="sd">    --------</span>
<span class="sd">    cluster_map:</span>
<span class="sd">    The new clusters that the ids are in</span>
<span class="sd">    &#39;&#39;&#39;</span>
</pre></div>
</div>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">matplotlib_cmap_to_plotly</span><span class="p">(</span><span class="n">cmap</span><span class="p">,</span> <span class="n">entries</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Creates a colorscale used to create an interactive plot</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    cmap:</span>
<span class="sd">    The colormap</span>

<span class="sd">    entries:</span>
<span class="sd">    The colormap entries</span>

<span class="sd">    Returns</span>
<span class="sd">    --------</span>
<span class="sd">    colorscale:</span>
<span class="sd">    The colorscale for the interactive plot</span>
<span class="sd">    &#39;&#39;&#39;</span>
</pre></div>
</div>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">plotStarburstMap</span><span class="p">(</span><span class="n">som</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Interactive plot of the distance map and gradients of the SOM</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    som:</span>
<span class="sd">    The trained SOM</span>

<span class="sd">    Returns</span>
<span class="sd">    --------</span>
<span class="sd">    Plot of the distance map and gradients</span>
<span class="sd">    &#39;&#39;&#39;</span>
</pre></div>
</div>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">outliers_detection</span><span class="p">(</span><span class="n">clusters_df</span><span class="p">,</span><span class="n">som</span><span class="p">,</span><span class="n">scaled_curves</span><span class="p">,</span><span class="n">ids</span><span class="p">,</span><span class="n">outlier_percentage</span> <span class="o">=</span> <span class="mf">0.2</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Gives the percentage of the clusters that have high quanitization errors (defined by percentile) for each cluster</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    clusters_df:</span>
<span class="sd">    A map of each of the ids to the clusters</span>

<span class="sd">    som:</span>
<span class="sd">    The trained SOM</span>

<span class="sd">    scaled_curves: np.ndarray</span>
<span class="sd">    The scaled curves used to train the SOM</span>

<span class="sd">    ids: list</span>
<span class="sd">    The ids of the curves</span>

<span class="sd">    outlier_percentage: float</span>
<span class="sd">    This top percentile that defines an outlier</span>

<span class="sd">    Returns</span>
<span class="sd">    --------</span>
<span class="sd">    Plots:</span>
<span class="sd">    Distribution of Outliers per cluster and distribution of quantization error</span>
<span class="sd">    &#39;&#39;&#39;</span>
</pre></div>
</div>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">Cluster_Metrics</span><span class="p">(</span><span class="n">scaled_curves</span><span class="p">,</span><span class="n">cluster_map</span><span class="p">,</span><span class="n">metric</span> <span class="o">=</span> <span class="s1">&#39;Silhoutte&#39;</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Measures metrics related to the clustering</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    scaled_curves: np.ndarray</span>
<span class="sd">    The scaled curves used to train the SOM</span>

<span class="sd">    cluster_map: pd.Dataframe</span>
<span class="sd">    A map of each of the ids to the clusters</span>

<span class="sd">    metric: str</span>
<span class="sd">    The metric to be measured. It can be Silhoutte, DBI or CH. This is for silhoutte score, Davies-Bouldin index and calinski-harabasz score</span>

<span class="sd">    Returns</span>
<span class="sd">    --------</span>
<span class="sd">    score:</span>
<span class="sd">    The metric that is calculated</span>
<span class="sd">    &#39;&#39;&#39;</span>
</pre></div>
</div>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">save_chosen_cluster</span><span class="p">(</span><span class="n">chosen_cluster</span><span class="p">,</span><span class="n">cluster_map</span><span class="p">,</span><span class="n">one_filter</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span><span class="n">filters</span> <span class="o">=</span> <span class="s1">&#39;a&#39;</span><span class="p">,</span><span class="n">overwrite</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span><span class="n">save_path</span> <span class="o">=</span> <span class="s1">&#39;./&#39;</span><span class="p">,</span><span class="n">source_path</span> <span class="o">=</span> <span class="s1">&#39;./Light_Curves&#39;</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd"> Saves the chosen cluster into a folder</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd"> chosen_cluster: int</span>
<span class="sd">    The cluster to save</span>

<span class="sd">    cluster_map: pd.Dataframe</span>
<span class="sd">    A map of each of the ids to the clusters</span>

<span class="sd">    one_filter: bool</span>
<span class="sd">    Whether to save just one filter or all the filters</span>

<span class="sd">    filters: str</span>
<span class="sd"> The filters to save</span>

<span class="sd">    overwrite: bool</span>
<span class="sd">    Whether to overwrite the current folder</span>

<span class="sd">    save_path: str</span>
<span class="sd">    The path to save to. This creates a folder for the cluster in that directory</span>

<span class="sd">    source_path: str</span>
<span class="sd"> The path that the light curves are saved in. If multifilter, provide the entire larger folder.</span>
<span class="sd">    &#39;&#39;&#39;</span>
</pre></div>
</div>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">scale_to_range</span><span class="p">(</span><span class="n">series</span><span class="p">,</span> <span class="n">min_val</span><span class="o">=-</span><span class="mi">2</span><span class="p">,</span> <span class="n">max_val</span><span class="o">=</span><span class="mi">2</span><span class="p">):</span>
<span class="w">     </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">     Scales a series to a range</span>

<span class="sd">     Parameters</span>
<span class="sd">     ----------</span>
<span class="sd">     series: pd.Series</span>
<span class="sd">     The series to scale</span>

<span class="sd">     min_val: int</span>
<span class="sd">     The minimum value to scale to</span>

<span class="sd">     max_val: int</span>
<span class="sd">     The maximum value to scale to</span>

<span class="sd">     Returns</span>
<span class="sd">     --------</span>
<span class="sd">     scaled_series:</span>
<span class="sd">     The scaled series between the max and min values</span>
<span class="sd">     &#39;&#39;&#39;</span>
</pre></div>
</div>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">masked_euclidean_distance</span><span class="p">(</span><span class="n">data1</span><span class="p">,</span> <span class="n">data2</span><span class="p">,</span> <span class="n">mask</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Calculates the masked euclidean distance between two arrays using a common mask</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    data1: np.ndarray</span>
<span class="sd">    The first array</span>

<span class="sd">    data2: np.ndarray</span>
<span class="sd">    The second array</span>

<span class="sd">    mask: np.ma.mask</span>
<span class="sd">    The mask used to get the distance</span>

<span class="sd">    Returns</span>
<span class="sd">    --------</span>
<span class="sd">    masked_distance:</span>
<span class="sd"> The masked distance measure</span>
<span class="sd">    &#39;&#39;&#39;</span>
</pre></div>
</div>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">multi_band_clustering</span><span class="p">(</span><span class="n">light_curves</span><span class="p">,</span><span class="n">ids</span><span class="p">,</span><span class="n">filter_names</span> <span class="o">=</span> <span class="s1">&#39;ugriz&#39;</span><span class="p">,</span><span class="n">som_x</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span><span class="n">som_y</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span><span class="n">sigma</span> <span class="o">=</span> <span class="mf">1.0</span><span class="p">,</span><span class="n">learning_rate</span> <span class="o">=</span> <span class="mf">0.5</span><span class="p">,</span>\
<span class="n">num_iterations</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span><span class="n">batch_size</span> <span class="o">=</span> <span class="mi">5</span><span class="p">,</span><span class="n">early_stopping_no</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Multiband light curve clustering</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    light_curves:</span>
<span class="sd">    The light curves to be used</span>

<span class="sd">    ids: list,array</span>
<span class="sd">    The ids of the quasars</span>

<span class="sd">    filter_names: list or str(if the filters are one letter)</span>
<span class="sd">    The filters that are used</span>

<span class="sd">    som_x: int</span>
<span class="sd">    The x size of the SOM. If None is given, make sure the som_y is None as well. Then, it chooses the recommended SOM</span>
<span class="sd">    size of sqrt(sqrt(length))</span>

<span class="sd">    som_y: int</span>
<span class="sd">    The y size of the SOM. If None is given, make sure the som_x is None as well. Then, it chooses the recommended SOM</span>
<span class="sd">    size of sqrt(sqrt(length))</span>

<span class="sd">    sigma: float</span>
<span class="sd">    The effect each node has on its neighboring nodes</span>

<span class="sd">    learning_rate: float</span>
<span class="sd">    How much the SOM learns from the new data that it sees</span>

<span class="sd">    num_iterations: int</span>
<span class="sd">    The number of iterations that the som is trained on each batch</span>

<span class="sd"> batch_size: int</span>
<span class="sd">    The size of each batch</span>

<span class="sd">    early_stopping_no: int or None</span>
<span class="sd">    The number of batches to process before stopping. Use None if you should train on all</span>

<span class="sd">    Returns</span>
<span class="sd">    --------</span>
<span class="sd">    som:</span>
<span class="sd">    The trained SOM</span>

<span class="sd">    processed_light_curve:</span>
<span class="sd">    The flat light curves used for the SOM</span>

<span class="sd">    processed_mask:</span>
<span class="sd">    The mask used for the SOM</span>
<span class="sd">    &#39;&#39;&#39;</span>
</pre></div>
</div>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">find_cluster_and_quantization_errors</span><span class="p">(</span><span class="n">som</span><span class="p">,</span><span class="n">data</span><span class="p">,</span><span class="n">masks</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Finding the clusters and the quantization errors from the trained 2D SOM</span>

<span class="sd">    Parameters</span>
<span class="sd"> ----------</span>
<span class="sd">    som:</span>
<span class="sd">    The trained SOM</span>

<span class="sd">    data:</span>
<span class="sd">    The processed light curves from the trained SOM</span>

<span class="sd">    masks:</span>
<span class="sd">    The masks used from the trained SOM</span>

<span class="sd">    Returns</span>
<span class="sd">    --------</span>
<span class="sd">    min_clusters:</span>
<span class="sd">    The clusters for each of the data points</span>

<span class="sd">    quantization_error:</span>
<span class="sd">    The quantization error of each of the data points</span>
<span class="sd">    &#39;&#39;&#39;</span>
</pre></div>
</div>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">Get_Gradient_Cluster_2D</span><span class="p">(</span><span class="n">som</span><span class="p">,</span><span class="n">fill</span> <span class="o">=</span> <span class="s1">&#39;mean&#39;</span><span class="p">,</span><span class="n">interpolation_kind</span> <span class="o">=</span> <span class="s1">&#39;cubic&#39;</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Finding the gradient clusters from the 2D SOM</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    som:</span>
<span class="sd">    The trained SOM</span>

<span class="sd">    fill: str</span>
<span class="sd">    &#39;mean&#39; or &#39;interpolate&#39;. Either the empty values are filled with the mean or they are interpolated with a function</span>

<span class="sd">    interpolation_kind:</span>
<span class="sd">    Any of the scipy.interp1d interpolation kinds. Recommended to use cubic</span>

<span class="sd">    Returns</span>
<span class="sd">    --------</span>
<span class="sd">    cluster_centers:</span>
<span class="sd">    The cluster centers</span>

<span class="sd">    cluster_pos:</span>
<span class="sd">    The cluster positions</span>
<span class="sd">    &#39;&#39;&#39;</span>
</pre></div>
</div>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">create_dir_save_plot</span><span class="p">(</span><span class="n">path</span><span class="p">,</span><span class="n">plot_name</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    If there is no folder named plots in the path, it creates one and saves an figure</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    path: str</span>
<span class="sd">    The path to create the Plots folder in</span>

<span class="sd">    plot_name:</span>
<span class="sd">    The name to save the plot under</span>
<span class="sd">    &#39;&#39;&#39;</span>
</pre></div>
</div>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">tolerant_mean</span><span class="p">(</span><span class="n">arrs</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Calculates the mean of arrays without them having to be the same length</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    arrs:</span>
<span class="sd">    The arrays to calculate the mean for</span>

<span class="sd">    Returns</span>
<span class="sd">    --------</span>
<span class="sd">    mean:</span>
<span class="sd">    The tolerant mean of the arrays</span>

<span class="sd">    std:</span>
<span class="sd">    The tolerant std of the arrays</span>
<span class="sd">    &#39;&#39;&#39;</span>
</pre></div>
</div>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">get_best_grid</span><span class="p">(</span><span class="n">number_of_objects</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Creates a grid that is optimal for the number of objects</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    number_of_objects: int</span>
<span class="sd">    The number of objects to make the grid for</span>

<span class="sd">    Returns</span>
<span class="sd">    --------</span>
<span class="sd">    rows:</span>
<span class="sd">    The number of rows for the grid</span>

<span class="sd">    cols:</span>
<span class="sd">    The number of cols for the grid</span>
<span class="sd">    &#39;&#39;&#39;</span>
</pre></div>
</div>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">Averaging_Clusters</span><span class="p">(</span><span class="n">chosen_cluster</span><span class="p">,</span><span class="n">cluster_map</span><span class="p">,</span><span class="n">lcs</span><span class="p">,</span><span class="n">plot</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span><span class="n">dba</span> <span class="o">=</span> <span class="kc">True</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Creating a representation of the chosen cluster with the light curves and the average light curve</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    chosen_cluster: int</span>
<span class="sd">    The cluster of interest</span>

<span class="sd">    cluster_map: pd.Dataframe</span>
<span class="sd">    A map of each of the ids to the clusters</span>

<span class="sd">    lcs: list of list of pd.Dataframes</span>
<span class="sd">    The light curves (provide the input from just one filter)</span>

<span class="sd">    plot: bool</span>
<span class="sd">    Whether to plot or just return the average value</span>

<span class="sd">    dba: bool</span>
<span class="sd">    Whether to use Dynamic Barymetric Time Averaging or to use a simple mean of the light curves</span>

<span class="sd">    Returns</span>
<span class="sd">    --------</span>
<span class="sd">    average_x:</span>
<span class="sd">    The x_axis (i.e timesteps) of the average light curve</span>

<span class="sd">    average_y:</span>
<span class="sd">    The y_axis (i.e magnitudes) of the average light curve</span>

<span class="sd">    x:</span>
<span class="sd">    The timesteps of all the light curves concatenated into one array</span>

<span class="sd">    y:</span>
<span class="sd">    The magnitudes of all the light curves concatenated into one array</span>

<span class="sd">    len(x):</span>
<span class="sd">    The length of all the light curves</span>
<span class="sd">    &#39;&#39;&#39;</span>
</pre></div>
</div>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">Plot_All_Clusters</span><span class="p">(</span><span class="n">cluster_map</span><span class="p">,</span><span class="n">lcs</span><span class="p">,</span><span class="n">color</span> <span class="o">=</span> <span class="s1">&#39;tab:blue&#39;</span><span class="p">,</span><span class="n">dba</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span><span class="n">figsize</span> <span class="o">=</span> <span class="p">(</span><span class="mi">10</span><span class="p">,</span><span class="mi">10</span><span class="p">),</span><span class="n">save_figs</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span><span class="n">figs_save_path</span> <span class="o">=</span> <span class="s1">&#39;./&#39;</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Plots all of the clusters on a magnitude plot with the average representation included</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    cluster_map: pd.Dataframe</span>
<span class="sd">    A map of each of the ids to the clusters</span>

<span class="sd">    lcs: list of list of pd.Dataframes</span>
<span class="sd">    The light curves (provide the input from just one filter)</span>

<span class="sd">    color: str</span>
<span class="sd">    The color to plot the averaged curve in</span>

<span class="sd">    dba: bool</span>
<span class="sd">    Whether to use Dynamic Barymetric Time Averaging or to use a simple mean of the light curves</span>

<span class="sd">    figsize: tuple</span>
<span class="sd">    The figure size</span>

<span class="sd">    save_figs: bool</span>
<span class="sd">    Whether to save the figure or not</span>

<span class="sd">    figs_save_path: str</span>
<span class="sd">    Where to save the figure. Note that it is saved under a directory called Plots in that directory.</span>
<span class="sd">    &#39;&#39;&#39;</span>
</pre></div>
</div>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">get_redshifts</span><span class="p">(</span><span class="n">redshifts_map</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Gets all the redshifts from a redshifts map</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    redshifts_map:  pd.Dataframe</span>
<span class="sd">    The mapping of ids to redshifts</span>

<span class="sd">    Returns</span>
<span class="sd">    --------</span>
<span class="sd">    redshifts:</span>
<span class="sd">    The list of redshifts</span>
<span class="sd">    &#39;&#39;&#39;</span>
</pre></div>
</div>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">get_fvars</span><span class="p">(</span><span class="n">lcs</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Calculates the variability function of the light curves</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    lcs:  List of pd.Dataframes</span>
<span class="sd">    The light curves of interest</span>

<span class="sd">    Returns</span>
<span class="sd">    --------</span>
<span class="sd">    fvars:</span>
<span class="sd">    The list of variability functions</span>
<span class="sd">    &#39;&#39;&#39;</span>
</pre></div>
</div>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">get_luminosities_and_masses</span><span class="p">(</span><span class="n">lcs</span><span class="p">,</span> <span class="n">redshifts_map</span><span class="p">,</span> <span class="n">H0</span> <span class="o">=</span> <span class="mf">67.4</span><span class="p">,</span> <span class="n">Om0</span> <span class="o">=</span> <span class="mf">0.315</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Randomly samples the luminosity and masses of the quasar black holes assuming a given Hubble Constant, Omega_0, and redshift</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    lcs:  List of pd.Dataframes</span>
<span class="sd">    The light curves of interest</span>

<span class="sd">    redshifts_map: pd.DataFrame</span>
<span class="sd">    The map from the ids to their redshifts</span>

<span class="sd">    H0: float</span>
<span class="sd">    The hubble constant at z=0</span>

<span class="sd">    Om0: float</span>
<span class="sd">    Omega matter: density of non-relativistic matter in units of the critical density at z=0.</span>

<span class="sd">    Returns</span>
<span class="sd">    --------</span>
<span class="sd">    Log_lum:</span>
<span class="sd">    The logarithm of the luminosities</span>

<span class="sd">    Log_Mass:</span>
<span class="sd">    The logarithm of the masses</span>
<span class="sd">    &#39;&#39;&#39;</span>
</pre></div>
</div>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">Cluster_Properties</span><span class="p">(</span><span class="n">cluster_map</span><span class="p">,</span><span class="n">selected_cluster</span><span class="p">,</span><span class="n">lcs</span><span class="p">,</span><span class="n">redshifts_map</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span><span class="n">plot</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span><span class="n">return_values</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>\
<span class="n">the_property</span> <span class="o">=</span> <span class="s1">&#39;all&#39;</span><span class="p">,</span><span class="n">save_figs</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span><span class="n">figs_save_path</span> <span class="o">=</span> <span class="s1">&#39;./&#39;</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Getting the selected property of a chosen cluster</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    cluster_map: pd.Dataframe</span>
<span class="sd">    A map of each of the ids to the clusters</span>

<span class="sd">    chosen_cluster: int</span>
<span class="sd">    The cluster of interest</span>

<span class="sd">    lcs: list of list of pd.Dataframes</span>
<span class="sd">    The light curves (provide the input from just one filter)</span>

<span class="sd">    redshifts_map: pd.Dataframe</span>
<span class="sd">    The redshift associated with each source id</span>

<span class="sd">    plot: bool</span>
<span class="sd">    Whether to plot or just return the average value</span>

<span class="sd">    return_values: bool</span>
<span class="sd">    Whether to return the values for the property</span>

<span class="sd">    the_property: str</span>
<span class="sd">    The property to plot. Choice from z (redshift), Fvar (the variability function), Lum (luminosity), Mass, or all</span>

<span class="sd">    save_figs: bool</span>
<span class="sd">    Whether to save the figure or not</span>

<span class="sd">    figs_save_path: str</span>
<span class="sd">    Where to save the figure. Note that it is saved under a directory called Plots in that directory.</span>

<span class="sd">    Returns</span>
<span class="sd">    --------</span>
<span class="sd">    return_list:</span>
<span class="sd">    The list of the property of interest</span>
<span class="sd">    &#39;&#39;&#39;</span>
</pre></div>
</div>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">Cluster_Properties_Comparison</span><span class="p">(</span><span class="n">cluster_map</span><span class="p">,</span><span class="n">lcs</span><span class="p">,</span><span class="n">redshifts_map</span><span class="p">,</span><span class="n">the_property</span> <span class="o">=</span> <span class="s1">&#39;Fvar&#39;</span><span class="p">,</span><span class="n">color</span> <span class="o">=</span> <span class="s1">&#39;#1f77b4&#39;</span><span class="p">,</span>\
<span class="n">figsize</span> <span class="o">=</span> <span class="p">(</span><span class="mi">15</span><span class="p">,</span><span class="mi">15</span><span class="p">),</span><span class="n">save_figs</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span><span class="n">figs_save_path</span> <span class="o">=</span> <span class="s1">&#39;./&#39;</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Plotting the property of interest for all the clusters onto one figure</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    cluster_map: pd.Dataframe</span>
<span class="sd">    A map of each of the ids to the clusters</span>

<span class="sd">    lcs: list of list of pd.Dataframes</span>
<span class="sd">    The light curves (provide the input from just one filter)</span>

<span class="sd">    redshifts_map: pd.Dataframe</span>
<span class="sd">    The redshift associated with each source id</span>

<span class="sd">    the_property: str</span>
<span class="sd">    The property to plot. Choice from z (redshift), Fvar (the variability function), Lum (luminosity), Mass, or all</span>

<span class="sd">    color: str</span>
<span class="sd">    The color to make the histogram</span>

<span class="sd">    figsize: tuple</span>
<span class="sd">    The figure size</span>

<span class="sd">    save_figs: bool</span>
<span class="sd">    Whether to save the figure or not</span>

<span class="sd">    figs_save_path: str</span>
<span class="sd">    Where to save the figure. Note that it is saved under a directory called Plots in that directory.</span>

<span class="sd">    Returns</span>
<span class="sd">    --------</span>
<span class="sd">    return_list:</span>
<span class="sd">    The list of the property of interest</span>
<span class="sd">    &#39;&#39;&#39;</span>
</pre></div>
</div>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">SFplus</span><span class="p">(</span><span class="n">magnitudes</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Calculates the S+ function of given light curves. S+ is the variance of magnitudes where the brightness increases</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    lcs:  List of pd.Dataframes</span>
<span class="sd">    The light curves of interest</span>

<span class="sd">    Returns</span>
<span class="sd">    --------</span>
<span class="sd">    sfplus:</span>
<span class="sd">    The list of S+</span>
<span class="sd">    &#39;&#39;&#39;</span>
</pre></div>
</div>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">SFminus</span><span class="p">(</span><span class="n">magnitudes</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Calculates the S- function of given light curves. S- is the variance of magnitudes where the brightness decreases</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    lcs:  List of pd.Dataframes</span>
<span class="sd">    The light curves of interest</span>

<span class="sd">    Returns</span>
<span class="sd">    --------</span>
<span class="sd">    sfminus:</span>
<span class="sd">    The list of S-</span>
<span class="sd">    &#39;&#39;&#39;</span>
</pre></div>
</div>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">SF</span><span class="p">(</span><span class="n">magnitudes</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Calculates the S function of given light curves. S is the variance of all magnitudes</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    lcs:  List of pd.Dataframes</span>
<span class="sd">    The light curves of interest</span>

<span class="sd">    Returns</span>
<span class="sd">    --------</span>
<span class="sd">    sf:</span>
<span class="sd">    The list of SFs</span>
<span class="sd">    &#39;&#39;&#39;</span>
</pre></div>
</div>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">Structure_Function</span><span class="p">(</span><span class="n">cluster_map</span><span class="p">,</span><span class="n">selected_cluster</span><span class="p">,</span><span class="n">lcs</span><span class="p">,</span><span class="n">bins</span><span class="p">,</span><span class="n">save_figs</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span><span class="n">figs_save_path</span> <span class="o">=</span> <span class="s1">&#39;./&#39;</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Create the structure function for a given cluster</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    cluster_map: pd.Dataframe</span>
<span class="sd">    A map of each of the ids to the clusters</span>

<span class="sd">    selected_cluster: int</span>
<span class="sd">    The cluster of interest</span>

<span class="sd">    lcs: list of list of pd.Dataframes</span>
<span class="sd">    The light curves (provide the input from just one filter)</span>

<span class="sd">    bins:int or list</span>
<span class="sd">    The bins to use for the structure function</span>

<span class="sd">    save_figs: bool</span>
<span class="sd">    Whether to save the figure or not</span>

<span class="sd">    figs_save_path: str</span>
<span class="sd">    Where to save the figure. Note that it is saved under a directory called Plots in that directory.</span>

<span class="sd">    Returns</span>
<span class="sd">    --------</span>
<span class="sd">    S+ and S- Plot:</span>
<span class="sd">    A plot of the S+ and S- functions for the cluster</span>

<span class="sd">    Difference Plot:</span>
<span class="sd">    The evolution of the normalized S+ - S- throughout the observation time of the cluster</span>

<span class="sd">    S Plot:</span>
<span class="sd">    The evolution of the (regular) structure function through the observation time of the cluster</span>
<span class="sd">    &#39;&#39;&#39;</span>
</pre></div>
</div>
</div></blockquote>
<p><strong>Preprocessing the Data</strong></p>
<blockquote>
<div><p><strong>`Preprocess.py`</strong></p>
<p>In this module, we transform data in the range [-2,2]x[-2,2] to make training faster. This module also contains two functions for cleaning the sample from outliers. If your sample does not require outlier cleaning, the functions can be skipped. Also, you can use your designed outlier cleaning function according to your data requirements. This module also contains a function for padding light curves. This function does not need to be used if your light curves have 100 or more points. It is important to emphasize that all light curves must have the same number of points in order to train the model correctly. By testing the package, we found that it is best to do backward padding with the last measured value up to 100 points. You use the padded light curves to train the model, and later, for prediction and plotting, these points are subtracted. According to the needs of the user, another method for padding can be done. The data transformation function in this module also creates subsets of the data named your_curve_name plus and your_curve_name_minus. These subsets are made with respect to errors in magnitudes and serve to augment the model’s training set. The original curves are saved as the name_of_your_curve_original.</p>
<p>Before running this script, you must create the following folders in the directory where your Python notebook is located:</p>
<ol class="arabic simple">
<li><p><cite>./preproc/</cite> - It is going to be the folder for saving the transformed data</p></li>
<li><p><cite>./padded_lc/</cite> - It is going to be the folder for saving the padded light curves</p></li>
<li><p><cite>./light_curves_clean/</cite> - It is going to be the folder for saving the light curves that are cleaned from outliers (this can be scipped)</p></li>
</ol>
<p>Your data must contain: <cite>mjd</cite> - MJD or time, <cite>mag</cite> - magnitude, and <cite>magerr</cite> - magnitude error</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">clean_and_save_outliers</span><span class="p">(</span><span class="n">input_folder</span><span class="p">,</span> <span class="n">output_folder</span><span class="p">,</span> <span class="n">threshold</span><span class="o">=</span><span class="mf">3.0</span><span class="p">):</span>
<span class="w">     </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">     Clean data in CSV files within the input folder, remove outliers, and save cleaned files in the output folder.</span>

<span class="sd">     Parameters:</span>
<span class="sd">   input_folder (str): Path to the folder containing input CSV files.</span>
<span class="sd">   output_folder (str): Path to the folder where cleaned CSV files will be saved.</span>
<span class="sd">   threshold (float, optional): Threshold for outlier detection in terms of standard deviations. Default is 3.0.</span>
<span class="sd">  &quot;&quot;&quot;</span>
</pre></div>
</div>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">clean_save_aggregate_data</span><span class="p">(</span><span class="n">input_folder</span><span class="p">,</span> <span class="n">output_folder</span><span class="p">,</span> <span class="n">threshold_aggregation</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">threshold_outliers</span><span class="o">=</span><span class="mf">3.0</span><span class="p">):</span>
<span class="w">     </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">     Clean data in CSV files within the input folder, remove outliers, aggregate time and fluxes,</span>
<span class="sd">     and save cleaned files in the output folder.</span>

<span class="sd">     Parameters:</span>
<span class="sd">     input_folder (str): Path to the folder containing input CSV files.</span>
<span class="sd">     output_folder (str): Path to the folder where cleaned CSV files will be saved.</span>
<span class="sd">     threshold_aggregation (float, optional): Threshold for time aggregation. Default is 5.</span>
<span class="sd">     threshold_outliers (float, optional): Threshold for outlier detection in terms of standard deviations. Default is 3.0.</span>
<span class="sd">     &quot;&quot;&quot;</span>
</pre></div>
</div>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">backward_pad_curves</span><span class="p">(</span><span class="n">folder_path</span><span class="p">,</span> <span class="n">output_folder</span><span class="p">,</span> <span class="n">desired_observations</span><span class="o">=</span><span class="mi">100</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Backward padding the light curves with the last observed value for mag and magerr.</span>
<span class="sd">    If your data contains &#39;time&#39; values it&#39;ll add +1 for padded values,</span>
<span class="sd">    and if your data contains &#39;MJD&#39; values it will add +0.2</span>

<span class="sd">    :param str folder_path: The path to a folder containing the .csv files.</span>
<span class="sd">    :param str output_path: The path to a folder for saving the padded lc.</span>
<span class="sd">    :param int desired_observations: The number of points that our package is demanding is 100 but it can be more.</span>

<span class="sd">    :return: The padded light curves.</span>
<span class="sd">    :rtype: object</span>

<span class="sd">    How to use:</span>
<span class="sd">    padding = backward_pad_curves(&#39;./light_curves&#39;, &#39;./padded_lc&#39;, desired_observations=100)</span>
<span class="sd">    &quot;&quot;&quot;</span>
</pre></div>
</div>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">transform</span><span class="p">(</span><span class="n">data</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Transforming data into [-2,2]x[-2,2] range. This function needs to be uploaded before using it.</span>

<span class="sd">    :param data: Your data must contain: MJD or time, mag-magnitude, and magerr-magnitude error.</span>
<span class="sd">    :type data: object</span>
<span class="sd">    &quot;&quot;&quot;</span>
</pre></div>
</div>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">transform_and_save</span><span class="p">(</span><span class="n">files</span><span class="p">,</span> <span class="n">DATA_SRC</span><span class="p">,</span> <span class="n">DATA_DST</span><span class="p">,</span> <span class="n">transform</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Transforms and saves a list of CSV files. The function also saves tr coefficients as a pickle file named trcoeff.pickle.</span>

<span class="sd">    :param list files: A list of CSV or TXT file names.</span>
<span class="sd">    :param str DATA_SRC: The path to the folder containing the CSV or TXT files.</span>
<span class="sd">    :param str DATA_DST: The path to the folder where the transformed CSV or TXT files will be saved.</span>
<span class="sd">    :param function transform: The transformation function defined previously.</span>

<span class="sd">    :return: A list of transformation coefficients for each file, where each element is a list containing the file name and the transformation coefficients Ax, Bx, Ay, and By.</span>
<span class="sd">    :rtype: list</span>

<span class="sd">    How to use:</span>
<span class="sd">    number_of_points, trcoeff = transform_and_save(files, DATA_SRC, DATA_DST, transform)</span>
<span class="sd">    &quot;&quot;&quot;</span>
</pre></div>
</div>
</div></blockquote>
<ol class="arabic simple" start="2">
<li><p><strong>SPLITTING AND TRAINING THE DATA</strong></p></li>
</ol>
<blockquote>
<div><p><strong>`SPLITTING_AND_TRAINING.py`</strong></p>
<p>We use this module to split the data into three subsamples that will serve as a test sample, a sample for model training, and a validation sample. This module also contains functions for training and saving models. It contains the following functions that must be executed in order.</p>
<p>Before running this script, you must create the following folders in the directory where your Python notebook is located:</p>
<ol class="arabic simple">
<li><p><cite>./dataset/train</cite> - folder for saving data for training after splitting your original dataset</p></li>
<li><p><cite>./dataset/test</cite> - folder for test data</p></li>
<li><p><cite>./dataset/val</cite> - folder for validation data</p></li>
<li><p><cite>./output</cite> - folder where you are going to save your trained model</p></li>
</ol>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">create_split_folders</span><span class="p">(</span><span class="n">train_folder</span><span class="o">=</span><span class="s1">&#39;./dataset/train/&#39;</span><span class="p">,</span> <span class="n">test_folder</span><span class="o">=</span><span class="s1">&#39;./dataset/test/&#39;</span><span class="p">,</span> <span class="n">val_folder</span><span class="o">=</span><span class="s1">&#39;./dataset/val/&#39;</span><span class="p">):</span>
<span class="w">     </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">     Creates a TRAIN, TEST, and VAL folders in the directory.</span>

<span class="sd">     :param str train_folder: Path for saving the train data.</span>
<span class="sd">     :param str test_folder: Path for test data.</span>
<span class="sd">     :param str val_folder: Path for validation data.</span>

<span class="sd">     How to use: create_split_folders(train_folder=&#39;./dataset/train/&#39;, test_folder=&#39;./dataset/test/&#39;, val_folder=&#39;./dataset/val/&#39;)</span>
<span class="sd">     &quot;&quot;&quot;</span>
</pre></div>
</div>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">split_data</span><span class="p">(</span><span class="n">files</span><span class="p">,</span> <span class="n">DATA_SRC</span><span class="p">,</span> <span class="n">TRAIN_FOLDER</span><span class="p">,</span> <span class="n">TEST_FOLDER</span><span class="p">,</span> <span class="n">VAL_FOLDER</span><span class="p">):</span>
<span class="w">     </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">     Splits the data into TRAIN, TEST, and VAL folders.</span>

<span class="sd">     :param list files: A list of CSV file names.</span>
<span class="sd">     :param str DATA_SRC: Path to preprocessed data.</span>
<span class="sd">     :param str TRAIN_FOLDER: Path for saving the train data.</span>
<span class="sd">     :param str TEST_FOLDER: Path for saving the test data.</span>
<span class="sd">     :param str VAL_FOLDER: Path for saving the validation data.</span>

<span class="sd">     How to use: split_data(files, DATA_SRC, TRAIN_FOLDER, TEST_FOLDER, VAL_FOLDER)</span>
<span class="sd">     &quot;&quot;&quot;</span>
</pre></div>
</div>
<p><strong>`TRAINING`</strong></p>
<p>Special note for mac os users:</p>
<p>When creating folders with mac operating systems, hidden <cite>.DS_Store</cite> files may be created. The user must delete these files before starting training from each folder. The best way is to go into each folder individually and run the command:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>!rm<span class="w"> </span>-f<span class="w"> </span>.DS_Store
</pre></div>
</div>
<p>Important note: Deleting files using the <cite>delete</cite> directly in the folders does not remove hidden files.</p>
<p>Before running the training function you must define:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">DATA_PATH_TRAIN</span> <span class="o">=</span> <span class="s2">&quot;./dataset/train&quot;</span> <span class="o">-</span> <span class="n">path</span> <span class="n">to</span> <span class="n">train</span> <span class="n">folder</span>
<span class="n">DATA_PATH_VAL</span> <span class="o">=</span> <span class="s2">&quot;./dataset/val&quot;</span> <span class="o">-</span> <span class="n">path</span> <span class="n">to</span> <span class="n">val</span> <span class="n">folder</span>

<span class="n">MODEL_PATH</span> <span class="o">=</span> <span class="s2">&quot;./output/cnp_model.pth&quot;</span> <span class="o">-</span> <span class="n">folder</span> <span class="k">for</span> <span class="n">saving</span> <span class="n">model</span>

<span class="n">BATCH_SIZE</span> <span class="o">=</span> <span class="mi">32</span> <span class="o">-</span> <span class="n">training</span> <span class="n">batch</span> <span class="n">size</span> <span class="n">MUST</span> <span class="n">REMAIN</span> <span class="mi">32</span>
<span class="n">EPOCHS</span> <span class="o">=</span> <span class="mi">6000</span> <span class="o">-</span> <span class="n">This</span> <span class="ow">is</span> <span class="n">optional</span>
<span class="n">EARLY_STOPPING_LIMIT</span> <span class="o">=</span> <span class="mi">3000</span> <span class="o">-</span> <span class="n">This</span> <span class="ow">is</span> <span class="n">optional</span>
</pre></div>
</div>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">get_data_loader</span><span class="p">(</span><span class="n">data_path_train</span><span class="p">,</span> <span class="n">data_path_val</span><span class="p">,</span> <span class="n">batch_size</span><span class="p">):</span>
<span class="w"> </span><span class="sd">&quot;&quot;&quot;</span>

<span class="sd"> --- Defining train and validation loader for training process and validation</span>


<span class="sd">   Args:</span>
<span class="sd">   :param str data_path_train: path to train folder</span>
<span class="sd">   :param str data_path_val: path to val folder</span>
<span class="sd">   :param batch_size: it is recommended to be 32</span>

<span class="sd">   How to use: trainLoader, valLoader = get_data_loader(DATA_PATH_TRAIN,BATCH SIZE)</span>
<span class="sd"> &quot;&quot;&quot;</span>
</pre></div>
</div>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">create_model_and_optimizer</span><span class="p">():</span>
<span class="w"> </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">   --Defines the model as Deterministic Model, optimizer as torch optimizer, criterion as LogProbLoss, mseMetric as MSELoss and maeMetric as MAELoss</span>

<span class="sd">   How to use: model, optimizer, criterion, mseMetric, maeMetric = create_model_and_optimizer(device)</span>
<span class="sd">    Device has to be defined before and it can be cuda or cpu</span>
<span class="sd"> &quot;&quot;&quot;</span>
</pre></div>
</div>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">train_model</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">train_loader</span><span class="p">,</span> <span class="n">val_loader</span><span class="p">,</span><span class="n">criterion</span><span class="p">,</span> <span class="n">optimizer</span><span class="p">,</span> <span class="n">num_runs</span><span class="p">,</span> <span class="n">epochs</span><span class="p">,</span> <span class="n">early_stopping_limit</span><span class="p">,</span> <span class="n">mse_metric</span><span class="p">,</span> <span class="n">maeMetric</span><span class="p">,</span> <span class="n">device</span><span class="p">):</span>
<span class="w"> </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd"> -- Trains the model</span>


<span class="sd"> Args:</span>
<span class="sd"> model: Deterministic model</span>
<span class="sd"> train_loader: train loader</span>
<span class="sd"> val_loader: validation loader</span>
<span class="sd"> criterion: criterion</span>
<span class="sd"> optimizer: torch optimizer</span>
<span class="sd"> num_runs: The number of trainings</span>
<span class="sd"> epochs: epochs for training. This is optional, but minimum of 3000 is recomended</span>
<span class="sd"> early_stopping_limit: limits the epochs for stopping the training. This is optional but minimum of 1500 is recomended</span>
<span class="sd"> mse_metric: mse metric</span>
<span class="sd"> mae_metric: mae metric</span>
<span class="sd"> device: torch device cpu or cuda</span>

<span class="sd">  How to use: If you want to save history_loss_train, history_loss_val, history_mse_train and history_mse_val for plotting you train your model like:</span>

<span class="sd"> history_loss_train, history_loss_val, history_mse_train, history_mse_val, history_mae_train, history_mae_val, epoch_counter_train_loss, epoch_counter_train_mse, epoch_counter_train_mae, epoch_counter_val_loss, epoch_counter_val_mse, epoch_counter_val_mae = st.train_model(model, trainLoader, valLoader, criterion, optimizer, 1, 3000, 1500, mseMetric, maeMetric, device)</span>

<span class="sd"> &quot;&quot;&quot;</span>
</pre></div>
</div>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">save_lists_to_csv</span><span class="p">(</span><span class="n">file_names</span><span class="p">,</span><span class="n">lists</span><span class="p">):</span>
<span class="w"> </span><span class="sd">&quot;&quot;&quot;</span>

<span class="sd"> --saving the histories to lists</span>


<span class="sd"> args:</span>
<span class="sd"> :param list file_names: A list of file names to be used for saving the data. Each file name corresponds to a specific data list that will be saved in CSV format.</span>
<span class="sd"> :param list lists: A list of lists containing the data to be saved. Each inner list represents a set of rows to be written to a CSV file.</span>

<span class="sd"> How to use:</span>
<span class="sd"> # Define the file names for saving the lists</span>
<span class="sd"> file_names = [&quot;history_loss_train.csv&quot;, &quot;history_loss_val.csv&quot;, &quot;history_mse_train.csv&quot;, &quot;history_mse_val.csv&quot;,&quot;history_mae_train.csv&quot;, &quot;history_mae_val.csv&quot;, &quot;epoch_counter_train_loss.csv&quot;, &quot;epoch_counter_train_mse.csv&quot;, &quot;epoch_counter_train_mae.csv&quot;, &quot;epoch_counter_val_loss.csv&quot;,&quot;epoch_counter_val_mse.csv&quot;, &quot;epoch_counter_val_mae.csv&quot;]</span>

<span class="sd"> # Define the lists</span>
<span class="sd"> lists = [history_loss_train, history_loss_val, history_mse_train, history_mse_val, history_mae_train,</span>
<span class="sd"> history_mae_val, epoch_counter_train_loss, epoch_counter_train_mse, epoch_counter_train_mae,</span>
<span class="sd"> epoch_counter_val_loss, epoch_counter_val_mse, epoch_counter_val_mae]</span>

<span class="sd"> save_list= save_lists_to_csv(file_names, lists)</span>
<span class="sd"> &quot;&quot;&quot;</span>
</pre></div>
</div>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">plot_loss</span><span class="p">(</span><span class="n">history_loss_train_file</span><span class="p">,</span> <span class="n">history_loss_val_file</span><span class="p">,</span> <span class="n">epoch_counter_train_loss_file</span><span class="p">):</span>
<span class="w">   </span><span class="sd">&quot;&quot;&quot;</span>

<span class="sd">   -- plotting the history losses</span>


<span class="sd">   Args:</span>
<span class="sd">   returned data from test_model</span>
<span class="sd">   How to use:</span>

<span class="sd">   history_loss_train_file = &#39;./history_loss_train.csv&#39;  # Replace with the path to your history_loss_train CSV file</span>
<span class="sd">   history_loss_val_file = &#39;./history_loss_val.csv&#39;  # Replace with the path to your history_loss_val CSV file</span>
<span class="sd">   epoch_counter_train_loss_file = &#39;./epoch_counter_train_loss.csv&#39;  # Replace with the path to your epoch_counter_train_loss CSV file</span>

<span class="sd">   logprobloss=plot_loss(history_loss_train_file, history_loss_val_file, epoch_counter_train_loss_file)</span>

<span class="sd">   &quot;&quot;&quot;</span>
</pre></div>
</div>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">plot_mse_metric</span><span class="p">(</span><span class="n">history_mse_train_file</span><span class="p">,</span> <span class="n">history_mse_val_file</span><span class="p">,</span> <span class="n">epoch_counter_train_mse_file</span><span class="p">):</span>
<span class="w">   </span><span class="sd">&quot;&quot;&quot;</span>

<span class="sd">   -- plotting the mse metric</span>


<span class="sd">    args:</span>
<span class="sd">    returned data from test_model</span>
<span class="sd">    How to use:</span>

<span class="sd">   history_mse_train_file = &#39;./history_mse_train.csv&#39;  # Replace with the path to your history_mse_train CSV file</span>
<span class="sd">   history_mse_val_file = &#39;./history_mse_val.csv&#39;  # Replace with the path to your history_mse_val CSV file</span>
<span class="sd">   epoch_counter_train_mse_file = &#39;./epoch_counter_train_mse.csv&#39;  # Replace with the path to your epoch_counter_train_mse CSV file</span>

<span class="sd">   msemetric=plot_mse(history_mse_train_file, history_mse_val_file, epoch_counter_train_mse_file)</span>

<span class="sd">   &quot;&quot;&quot;</span>
</pre></div>
</div>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">plot_mae_metric</span><span class="p">(</span><span class="n">history_mae_train_file</span><span class="p">,</span> <span class="n">history_mae_val_file</span><span class="p">,</span> <span class="n">epoch_counter_train_mae_file</span><span class="p">):</span>
<span class="w">   </span><span class="sd">&quot;&quot;&quot;</span>

<span class="sd">   -- plotting the mae metric</span>


<span class="sd">     args:</span>
<span class="sd">   returned data from test_model</span>
<span class="sd">   How to use:</span>

<span class="sd">   history_mae_train_file = &#39;./history_mae_train.csv&#39;  # Replace with the path to your history_mae_train CSV file</span>
<span class="sd">   history_mae_val_file = &#39;./history_mae_val.csv&#39;  # Replace with the path to your history_mae_val CSV file</span>
<span class="sd">   epoch_counter_train_mae_file = &#39;./epoch_counter_train_mae.csv&#39;  # Replace with the path to your epoch_counter_train_mae CSV file</span>

<span class="sd">   maemetric=plot_mae(history_mae_train_file, history_mae_val_file, epoch_counter_train_mae_file)</span>
<span class="sd">   &quot;&quot;&quot;</span>
</pre></div>
</div>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">save_model</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">MODEL_PATH</span><span class="p">):</span>
<span class="w">   </span><span class="sd">&quot;&quot;&quot;</span>

<span class="sd">   -- saving the model</span>


<span class="sd">   Args:</span>
<span class="sd">   model: Deterministic model</span>
<span class="sd">   :param str MODEL_PATH: output path for saving the model</span>

<span class="sd">   How to use: save_model(model, MODEL_PATH)</span>
<span class="sd">   &quot;&quot;&quot;</span>
</pre></div>
</div>
</div></blockquote>
<ol class="arabic simple" start="3">
<li><p><strong>PREDICTION AND PLOTTING THE TRANSFORMED DATA, EACH CURVE INDIVIDUALLY</strong></p></li>
</ol>
<blockquote>
<div><p><strong>`PREDICTION.py`</strong></p>
<p>We use this module for prediction and plotting of models of transformed data. Each curve will be plotted separately. It contains the following functions that must be executed in order.</p>
<p>Before running this script, you must create the following folders in the directory where your Python notebook is located:</p>
<ol class="arabic simple">
<li><p><cite>./output/predictions/train/plots</cite> - folder for saving training plots</p></li>
<li><p><cite>./output/predictions/test/plots</cite> - folder for saving test plots</p></li>
<li><p><cite>./output/predictions/val/plots</cite> - folder for saving validation plots</p></li>
<li><p><cite>./output/predictions/train/data</cite> - folder for sving train data</p></li>
<li><p><cite>./output/predictions/test/data</cite> - folder for saving test data</p></li>
<li><p><cite>./output/predictions/val/data</cite> - folder for saving val data</p></li>
</ol>
<blockquote>
<div><div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">prepare_output_dir</span><span class="p">(</span><span class="n">OUTPUT_PATH</span><span class="p">):</span>
<span class="w">   </span><span class="sd">&quot;&quot;&quot;</span>

<span class="sd">   -- the function prepare_output_dir takes the `OUTPUT_PATH` as an argument and removes all files in the output directory using os.walk method.</span>


<span class="sd">   Args:</span>
<span class="sd">   :param str OUTPUT_PATH: path to output folder</span>

<span class="sd">   How to use: prepare_output_dir(OUTPUT_PATH)</span>
<span class="sd">   &quot;&quot;&quot;</span>
</pre></div>
</div>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">load_trained_model</span><span class="p">(</span><span class="n">MODEL_PATH</span><span class="p">,</span> <span class="n">device</span><span class="p">):</span>
<span class="w">   </span><span class="sd">&quot;&quot;&quot;</span>

<span class="sd">   --Uploading trained model</span>


<span class="sd">   agrs:</span>
<span class="sd">   :param str MODEL_PATH = path to model directorium</span>
<span class="sd">   :param device = torch device CPU or CUDA</span>
<span class="sd">   How to use: model=load_trained_model(MODEL_PATH, device)</span>
<span class="sd">   &quot;&quot;&quot;</span>
</pre></div>
</div>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">get_criteria</span><span class="p">():</span>
<span class="w">   </span><span class="sd">&quot;&quot;&quot;</span>

<span class="sd">   -- Gives the criterion and mse_metric</span>

<span class="sd">   How to use: criterion, mseMetric=get_criteria()</span>
<span class="sd">   &quot;&quot;&quot;</span>
</pre></div>
</div>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">remove_padded_values_and_filter</span><span class="p">(</span><span class="n">folder_path</span><span class="p">):</span>
<span class="w">   </span><span class="sd">&quot;&quot;&quot;</span>

<span class="sd">   -- Preparing data for plotting. It&#39;ll remove the padded values from lc and it&#39;ll delete artifitially added lc with plus and minus errors. If your lc are not padded it&#39;ll only delete additional curves</span>


<span class="sd">   Args:</span>
<span class="sd">   :param str folder_path: Path to folder where the curves are. In this case it&#39;ll be &#39;./dataset/test&#39; or &#39;./dataset/train&#39; or &#39;./dataset/val&#39;</span>

<span class="sd">   How to use:</span>
<span class="sd">   if __name__ == &quot;__main__&quot;:</span>
<span class="sd">   folder_path = &quot;./dataset/test&quot;  # Change this to your dataset folder</span>

<span class="sd">   remove_padded_values_and_filter(folder_path)</span>
<span class="sd">   &quot;&quot;&quot;</span>
</pre></div>
</div>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">plot_function</span><span class="p">(</span><span class="n">target_x</span><span class="p">,</span> <span class="n">target_y</span><span class="p">,</span> <span class="n">context_x</span><span class="p">,</span> <span class="n">context_y</span><span class="p">,</span> <span class="n">pred_y</span><span class="p">,</span> <span class="n">var</span><span class="p">,</span> <span class="n">target_test_x</span><span class="p">,</span> <span class="n">lcName</span><span class="p">,</span> <span class="n">save</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">flagval</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">isTrainData</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">notTrainData</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
<span class="w">   </span><span class="sd">&quot;&quot;&quot;</span>

<span class="sd">   -- Defines the plots of the light curve data and predicted mean and variance, and it should be imported separately</span>


<span class="sd">   Args:</span>
<span class="sd">   :param context_x: Array of shape BATCH_SIZE x NUM_CONTEXT that contains the x values of the context points.</span>
<span class="sd">   :param context_y: Array of shape BATCH_SIZE x NUM_CONTEXT that contains the y values of the context points.</span>
<span class="sd">   :param target_x: Array of shape BATCH_SIZE x NUM_TARGET that contains the x values of the target points.</span>
<span class="sd">   :param target_y: Array of shape BATCH_SIZE x NUM_TARGET that contains the ground truth y values of the target points.</span>
<span class="sd">   :param target_test_x: Array of shape BATCH_SIZE x 400 that contains uniformly spread points across in [-2, 2] range.</span>
<span class="sd">   :param pred_y: Array of shape BATCH_SIZE x 400 that contains predictions across [-2, 2] range.</span>
<span class="sd">   :param var: An array of shape BATCH_SIZE x 400  that contains the variance of predictions at target_test_x points.</span>
<span class="sd">   &quot;&quot;&quot;</span>
</pre></div>
</div>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">load_test_data</span><span class="p">(</span><span class="n">data_path</span><span class="p">):</span>
<span class="w">   </span><span class="sd">&quot;&quot;&quot;</span>

<span class="sd">   -- takes data_path as an argument, creates a LighCurvesDataset and returns a PyTorch DataLoader for the test set. The DataLoader is used to load and preprocess the test data in batches</span>

<span class="sd">   Args:</span>
<span class="sd">   :param str data_path: path to Test data</span>

<span class="sd">   How to use: testLoader=load_test_data(DATA_PATH_TEST)</span>

<span class="sd">   &quot;&quot;&quot;</span>
</pre></div>
</div>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">load_train_data</span><span class="p">(</span><span class="n">data_path</span><span class="p">):</span>
<span class="w">   </span><span class="sd">&quot;&quot;&quot;</span>

<span class="sd">   -- takes data_path as an argument, creates a LighCurvesDataset and returns a PyTorch DataLoader for the test set. The DataLoader is used to load and preprocess the test data in batches</span>

<span class="sd">   Args:</span>
<span class="sd">   :param str data_path: path to train data</span>

<span class="sd">   How to use: trainLoader=load_train_data(DATA_PATH_TRAIN)</span>

<span class="sd">   &quot;&quot;&quot;</span>
</pre></div>
</div>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">load_val_data</span><span class="p">(</span><span class="n">data_path</span><span class="p">):</span>
<span class="w">   </span><span class="sd">&quot;&quot;&quot;</span>

<span class="sd">   -- takes data_path as an argument, creates a LighCurvesDataset and returns a PyTorch DataLoader for the test set. The DataLoader is used to load and preprocess the test data in batches</span>

<span class="sd">   Args:</span>
<span class="sd">   :param str data_path: path to VAL data</span>

<span class="sd">   How to use: valLoader=load_val_data(DATA_PATH_VAL)</span>

<span class="sd">   &quot;&quot;&quot;</span>
</pre></div>
</div>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">plot_light_curves_from_test_set</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">testLoader</span><span class="p">,</span> <span class="n">criterion</span><span class="p">,</span> <span class="n">mseMetric</span><span class="p">,</span> <span class="n">plot_function</span><span class="p">,</span> <span class="n">device</span><span class="p">):</span>
<span class="w">   </span><span class="sd">&quot;&quot;&quot;</span>

<span class="sd">   -- Ploting the transformed light curves from test set</span>


<span class="sd">   Args:</span>
<span class="sd">   :param model: Deterministic model</span>
<span class="sd">   :param testLoader: Uploaded test data</span>
<span class="sd">   :param criterion: criterion</span>
<span class="sd">   :param mseMetric: Mse Metric</span>
<span class="sd">   :param plot_function: plot function defined above</span>
<span class="sd">   :param device: torch device CPU or CUDA</span>

<span class="sd">   How to use: testMetrics = plot_light_curves_from_test_set(model, testLoader, criterion, mseMetric, plot_function, device)</span>
<span class="sd">   &quot;&quot;&quot;</span>
</pre></div>
</div>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">save_test_metrics</span><span class="p">(</span><span class="n">OUTPUT_PATH</span><span class="p">,</span> <span class="n">testMetrics</span><span class="p">):</span>
<span class="w">   </span><span class="sd">&quot;&quot;&quot;</span>

<span class="sd">   -- saving the test metrics as json file</span>


<span class="sd">   Args:</span>
<span class="sd">   :param str OUTPUT_PATH: path to output folder</span>
<span class="sd">   :param testMetrics: returned data from ploting function</span>

<span class="sd">    How to use: save_test_metrics(OUTPUT_PATH, testMetrics)</span>
<span class="sd">   &quot;&quot;&quot;</span>
</pre></div>
</div>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">plot_light_curves_from_train_set</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">trainLoader</span><span class="p">,</span> <span class="n">criterion</span><span class="p">,</span> <span class="n">mseMetric</span><span class="p">,</span> <span class="n">plot_function</span><span class="p">,</span> <span class="n">device</span><span class="p">):</span>
<span class="w">   </span><span class="sd">&quot;&quot;&quot;</span>

<span class="sd">   -- Ploting the transformed light curves from train set</span>


<span class="sd">   Args:</span>
<span class="sd">   :param model: Deterministic model</span>
<span class="sd">   :param trainLoader: Uploaded trained data</span>
<span class="sd">   :param criterion: criterion</span>
<span class="sd">   :param mseMetric: Mse Metric</span>
<span class="sd">   :param plot_function: plot function defined above</span>
<span class="sd">   :param device: torch device CPU or CUDA</span>

<span class="sd">   How to use: trainMetrics = plot_light_curves_from_train_set(model, trainLoader, criterion, mseMetric, plot_function, device)</span>
<span class="sd">   &quot;&quot;&quot;</span>
</pre></div>
</div>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">save_train_metrics</span><span class="p">(</span><span class="n">OUTPUT_PATH</span><span class="p">,</span> <span class="n">testMetrics</span><span class="p">)</span>
<span class="w">   </span><span class="sd">&quot;&quot;&quot;</span>

<span class="sd">   -- saving the train metrics as json file</span>


<span class="sd">   Args:</span>
<span class="sd">   :param str OUTPUT_PATH: path to output folder</span>
<span class="sd">   :param trainMetrics: returned data from ploting function</span>

<span class="sd">   How to use: save_train_metrics(OUTPUT_PATH, trainMetrics)</span>
<span class="sd">   &quot;&quot;&quot;</span>
</pre></div>
</div>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">plot_light_curves_from_val_set</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">valLoader</span><span class="p">,</span> <span class="n">criterion</span><span class="p">,</span> <span class="n">mseMetric</span><span class="p">,</span> <span class="n">plot_function</span><span class="p">,</span> <span class="n">device</span><span class="p">):</span>
<span class="w">   </span><span class="sd">&quot;&quot;&quot;</span>

<span class="sd">   -- Ploting the transformed light curves from validation set</span>


<span class="sd">   Args:</span>
<span class="sd">   :param model: Deterministic model</span>
<span class="sd">   :param valLoader: Uploaded val data</span>
<span class="sd">   :param criterion: criterion</span>
<span class="sd">   :param mseMetric: Mse Metric</span>
<span class="sd">   :param plot_function: plot function defined above</span>
<span class="sd">   :param device: torch device CPU or CUDA</span>

<span class="sd">   How to use: valMetrics = plot_light_curves_from_val_set(model, valLoader, criterion, mseMetric, plot_function, device)</span>
<span class="sd">   &quot;&quot;&quot;</span>
</pre></div>
</div>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">save_val_metrics</span><span class="p">(</span><span class="n">OUTPUT_PATH</span><span class="p">,</span> <span class="n">valMetrics</span><span class="p">):</span>
<span class="w">   </span><span class="sd">&quot;&quot;&quot;</span>

<span class="sd">   -- saving the validation metrics as json file</span>

<span class="sd">   Args:</span>
<span class="sd">   :param str OUTPUT_PATH: path to output folder</span>
<span class="sd">   :param valMetrics: returned data from ploting function</span>

<span class="sd">   How to use: save_val_metrics(OUTPUT_PATH, valMetrics)</span>
<span class="sd">   &quot;&quot;&quot;</span>
</pre></div>
</div>
</div></blockquote>
</div></blockquote>
<ol class="arabic simple" start="4">
<li><p><strong>PREDICTION AND PLOTTING THE TRANSFORMED DATA, IN ONE PDF FILE</strong></p></li>
</ol>
<blockquote>
<div><p><strong>`PREDICTION_onePDF.py`</strong></p>
<p>We use this module for prediction and plotting of models of transformed data. All curves will be plotted in one PDF file. This module contains the following functions that must be executed in order.</p>
<p>Before running this script, you must create the following folders in the directory where your Python notebook is located:</p>
<ol class="arabic simple">
<li><p><cite>./output/predictions/train/plots</cite> – folder for saving training plots</p></li>
<li><p><cite>./output/predictions/test/plots</cite> – folder for saving test plots</p></li>
<li><p><cite>./output/predictions/val/plots</cite> – folder for saving validation plots</p></li>
<li><p><cite>./output/predictions/train/data</cite> – folder for sving train data</p></li>
<li><p><cite>./output/predictions/test/data</cite> – folder for saving test data</p></li>
<li><p><cite>./output/predictions/val/data</cite> – folder for saving val data</p></li>
</ol>
<blockquote>
<div><div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">clear_output_dir</span><span class="p">(</span><span class="n">output_path</span><span class="p">):</span>
<span class="w">   </span><span class="sd">&quot;&quot;&quot;</span>

<span class="sd">   -- Removes all files in the specified output directory.</span>


<span class="sd">   Args:</span>
<span class="sd">   :param str output_path: The path to the output directory.</span>

<span class="sd">   How to use: clear_output_dir(OUTPUT_PATH)</span>

<span class="sd">   &quot;&quot;&quot;</span>
</pre></div>
</div>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">load_model</span><span class="p">(</span><span class="n">model_path</span><span class="p">,</span> <span class="n">device</span><span class="p">):</span>
<span class="w">   </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">   --Loads a trained model from disk and moves it to the specified device.</span>

<span class="sd">   Args:</span>
<span class="sd">   :param str model_path: The path to the saved model.</span>
<span class="sd">   :param str or torch.device device: The device to load the model onto, CPU or CUDA</span>

<span class="sd">   How to use: model = load_model(MODEL_PATH, device)</span>
<span class="sd">   &quot;&quot;&quot;</span>
</pre></div>
</div>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">get_criteria</span><span class="p">():</span>
<span class="w">   </span><span class="sd">&quot;&quot;&quot;</span>

<span class="sd">   -- Gives the criterion and mse_metric</span>


<span class="sd">   How to use: criterion, mseMetric=get_criteria()</span>
<span class="sd">   &quot;&quot;&quot;</span>
</pre></div>
</div>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">remove_padded_values_and_filter</span><span class="p">(</span><span class="n">folder_path</span><span class="p">):</span>
<span class="w">   </span><span class="sd">&quot;&quot;&quot;</span>

<span class="sd">   -- Preparing data for plotting. It&#39;ll remove the padded values from lc and it&#39;ll delete artifitially added lc with plus and minus errors. If your lc are not padded it&#39;ll only delete additional curves</span>


<span class="sd">     Args:</span>
<span class="sd">   :param str folder_path: Path to folder where the curves are. In this case it&#39;ll be &#39;./dataset/test&#39; or &#39;./dataset/train&#39; or &#39;./dataset/val&#39;</span>

<span class="sd">   How to use:</span>
<span class="sd">   if __name__ == &quot;__main__&quot;:</span>
<span class="sd">     folder_path = &quot;./dataset/test&quot;  # Change this to your dataset folder</span>

<span class="sd">   remove_padded_values_and_filter(folder_path)</span>
<span class="sd">   &quot;&quot;&quot;</span>
</pre></div>
</div>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">dev</span> <span class="n">plot_function</span><span class="p">(</span><span class="n">target_x</span><span class="p">,</span> <span class="n">target_y</span><span class="p">,</span> <span class="n">context_x</span><span class="p">,</span> <span class="n">context_y</span><span class="p">,</span> <span class="n">pred_y</span><span class="p">,</span> <span class="n">var</span><span class="p">,</span> <span class="n">target_test_x</span><span class="p">,</span> <span class="n">lcName</span><span class="p">,</span> <span class="n">save</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">flagval</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">isTrainData</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">notTrainData</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
<span class="w">   </span><span class="sd">&quot;&quot;&quot;</span>

<span class="sd">   -- Defines the plots of the light curve data and predicted mean and variance</span>


<span class="sd">     Args:</span>
<span class="sd">   context_x: Array of shape BATCH_SIZE x NUM_CONTEXT that contains the x values of the context points.</span>
<span class="sd">   context_y: Array of shape BATCH_SIZE x NUM_CONTEXT that contains the y values of the context points.</span>
<span class="sd">   target_x: Array of shape BATCH_SIZE x NUM_TARGET that contains the x values of the target points.</span>
<span class="sd">   target_y: Array of shape BATCH_SIZE x NUM_TARGET that contains the ground truth y values of the target points.</span>
<span class="sd">   target_test_x: Array of shape BATCH_SIZE x 400 that contains uniformly spread points across in [-2, 2] range.</span>
<span class="sd">   pred_y: Array of shape BATCH_SIZE x 400 that contains predictions across [-2, 2] range.</span>
<span class="sd">   var: An array of shape BATCH_SIZE x 400  that contains the variance of predictions at target_test_x points.</span>
<span class="sd">   &quot;&quot;&quot;</span>
</pre></div>
</div>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">load_test_data</span><span class="p">(</span><span class="n">data_path</span><span class="p">):</span>
<span class="w">   </span><span class="sd">&quot;&quot;&quot;</span>

<span class="sd">   -- takes data_path as an argument, creates a LighCurvesDataset and returns a PyTorch DataLoader for the test set. The DataLoader is used to load and preprocess the test data in batches</span>

<span class="sd">   Args:</span>
<span class="sd">   :param str data_path: path to Test data</span>

<span class="sd">   How to use: testLoader=load_test_data(DATA_PATH_TEST)</span>

<span class="sd">   &quot;&quot;&quot;</span>
</pre></div>
</div>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">load_train_data</span><span class="p">(</span><span class="n">data_path</span><span class="p">):</span>
<span class="w">   </span><span class="sd">&quot;&quot;&quot;</span>

<span class="sd">   -- takes data_path as an argument, creates a LighCurvesDataset and returns a PyTorch DataLoader for the test set. The DataLoader is used to load and preprocess the test data in batches</span>

<span class="sd">   Args:</span>
<span class="sd">   :param str data_path: path to train data</span>

<span class="sd">   How to use: trainLoader=load_train_data(DATA_PATH_TRAIN)</span>

<span class="sd">   &quot;&quot;&quot;</span>
</pre></div>
</div>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">load_val_data</span><span class="p">(</span><span class="n">data_path</span><span class="p">):</span>
<span class="w">   </span><span class="sd">&quot;&quot;&quot;</span>

<span class="sd">   -- takes data_path as an argument, creates a LighCurvesDataset and returns a PyTorch DataLoader for the test set. The DataLoader is used to load and preprocess the test data in batches</span>

<span class="sd">   Args:</span>
<span class="sd">   :param str data_path: path to VAL data</span>

<span class="sd">   How to use: valLoader=load_val_data(DATA_PATH_VAL)</span>

<span class="sd">   &quot;&quot;&quot;</span>
</pre></div>
</div>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">plot_test_light_curves</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">testLoader</span><span class="p">,</span> <span class="n">criterion</span><span class="p">,</span> <span class="n">mseMetric</span><span class="p">,</span> <span class="n">plot_function</span><span class="p">,</span> <span class="n">device</span><span class="p">):</span>
<span class="w">   </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">   -- ploting the test set in range [-2,2]</span>


<span class="sd">   Args:</span>
<span class="sd">   :param model: model</span>
<span class="sd">   :param testLoader: Test set</span>
<span class="sd">   :param criterion: criterion</span>
<span class="sd">   :param mseMetric: mse Metric</span>
<span class="sd">   :param plot_function: defined above</span>
<span class="sd">   :param device: Torch device, CPU or CUDA</span>


<span class="sd">   how to use: testMetrics=plot_test_light_curves(model, testLoader, criterion, mseMetric, plot_function, out_pdf_test, device)</span>
<span class="sd">   &quot;&quot;&quot;</span>
</pre></div>
</div>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">save_test_metrics</span><span class="p">(</span><span class="n">OUTPUT_PATH</span><span class="p">,</span> <span class="n">testMetrics</span><span class="p">):</span>
<span class="w">   </span><span class="sd">&quot;&quot;&quot;</span>

<span class="sd">   -- saving the test metrics as json file</span>


<span class="sd">   Args:</span>
<span class="sd">   :param str OUTPUT_PATH: path to output folder</span>
<span class="sd">   :param testMetrics: returned data from ploting function</span>

<span class="sd">   How to use: save_test_metrics(OUTPUT_PATH, testMetrics)</span>
<span class="sd">   &quot;&quot;&quot;</span>
</pre></div>
</div>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">plot_train_light_curves</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">trainLoader</span><span class="p">,</span> <span class="n">criterion</span><span class="p">,</span> <span class="n">mseMetric</span><span class="p">,</span> <span class="n">plot_function</span><span class="p">,</span> <span class="n">device</span><span class="p">):</span>
<span class="w">   </span><span class="sd">&quot;&quot;&quot;</span>

<span class="sd">   -- Ploting the transformed light curves from train set</span>


<span class="sd">   Args:</span>
<span class="sd">   :param model: Deterministic model</span>
<span class="sd">   :param trainLoader: Uploaded trained data</span>
<span class="sd">   :param criterion: criterion</span>
<span class="sd">   :param mseMetric: Mse Metric</span>
<span class="sd">   :param plot_function: plot function defined above</span>
<span class="sd">   :param device: torch device CPU or CUDA</span>


<span class="sd">   How to use: trainMetrics=plot_train_light_curves(model, trainLoader, criterion, mseMetric, plot_function, device)</span>
<span class="sd">   &quot;&quot;&quot;</span>
</pre></div>
</div>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">save_train_metrics</span><span class="p">(</span><span class="n">OUTPUT_PATH</span><span class="p">,</span> <span class="n">testMetrics</span><span class="p">)</span>
<span class="w">   </span><span class="sd">&quot;&quot;&quot;</span>

<span class="sd">   -- saving the train metrics as json file</span>


<span class="sd">   Args:</span>
<span class="sd">   :param str OUTPUT_PATH: path to output folder</span>
<span class="sd">   :param trainMetrics: returned data from ploting function</span>

<span class="sd">   How to use: save_train_metrics(OUTPUT_PATH, trainMetrics)</span>
<span class="sd">   &quot;&quot;&quot;</span>
</pre></div>
</div>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">plot_val_light_curves</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">valLoader</span><span class="p">,</span> <span class="n">criterion</span><span class="p">,</span> <span class="n">mseMetric</span><span class="p">,</span> <span class="n">plot_function</span><span class="p">,</span> <span class="n">device</span><span class="p">):</span>
<span class="w">   </span><span class="sd">&quot;&quot;&quot;</span>

<span class="sd">   -- Ploting the transformed light curves from val set</span>


<span class="sd">   Args:</span>
<span class="sd">   :param model: Deterministic model</span>
<span class="sd">   :param valLoader: Uploaded val data</span>
<span class="sd">   :param criterion: criterion</span>
<span class="sd">   :param mseMetric: Mse Metric</span>
<span class="sd">   :param plot_function: plot function defined above</span>
<span class="sd">   :param device: torch device CPU or CUDA</span>

<span class="sd">   How to use: valMetrics = plot_val_light_curves(model, valLoader, criterion, mseMetric, plot_function, device)</span>
<span class="sd">   &quot;&quot;&quot;</span>
</pre></div>
</div>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">save_val_metrics</span><span class="p">(</span><span class="n">OUTPUT_PATH</span><span class="p">,</span> <span class="n">valMetrics</span><span class="p">):</span>
<span class="w">   </span><span class="sd">&quot;&quot;&quot;</span>

<span class="sd">   -- saving the val metrics as json file</span>


<span class="sd">   Args:</span>
<span class="sd">   :param str OUTPUT_PATH: path to output folder</span>
<span class="sd">   :param valMetrics: returned data from ploting function</span>

<span class="sd">   How to use: save_val_metrics(OUTPUT_PATH, valMetrics)</span>
<span class="sd">   &quot;&quot;&quot;</span>
</pre></div>
</div>
</div></blockquote>
</div></blockquote>
<ol class="arabic simple" start="5">
<li><p><strong>PREDICTION AND PLOTTING THE DATA IN ORIGINAL DATA RANGE, EACH CURVE INDIVIDUALLY</strong></p></li>
</ol>
<blockquote>
<div><blockquote>
<div><p><strong>`PREDICTION_Original_mjd.py`</strong></p>
<p>We use this module to predict and plot the model in the original range of data. All curves are plotted individually. This module contains the following functions that must be executed in order.</p>
<p>Before running this script, you must create the following folders in the directory where your Python notebook is located:</p>
</div></blockquote>
<ol class="arabic simple">
<li><p><cite>./output/predictions/train/plots</cite> – folder for saving training plots</p></li>
<li><p><cite>./output/predictions/test/plots</cite> – folder for saving test plots</p></li>
<li><p><cite>./output/predictions/val/plots</cite> – folder for saving validation plots</p></li>
<li><p><cite>./output/predictions/train/data</cite> – folder for sving train data</p></li>
<li><p><cite>./output/predictions/test/data</cite> – folder for saving test data</p></li>
<li><p><cite>./output/predictions/val/data</cite> – folder for saving val data</p></li>
</ol>
<blockquote>
<div><div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">prepare_output_dir</span><span class="p">(</span><span class="n">OUTPUT_PATH</span><span class="p">):</span>
<span class="w">   </span><span class="sd">&quot;&quot;&quot;</span>

<span class="sd">   -- the function prepare_output_dir takes the OUTPUT_PATH       as an argument and removes all files in the output    directory using os.walk method.</span>


<span class="sd">   Args:</span>
<span class="sd">   :param str OUTPUT_PATH: path to output folder</span>

<span class="sd">   How to use: prepare_output_dir(OUTPUT_PATH)</span>
<span class="sd">   &quot;&quot;&quot;</span>
</pre></div>
</div>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">load_trained_model</span><span class="p">(</span><span class="n">MODEL_PATH</span><span class="p">,</span> <span class="n">device</span><span class="p">):</span>
<span class="w">   </span><span class="sd">&quot;&quot;&quot;</span>

<span class="sd">   --Uploading trained model</span>


<span class="sd">     agrs:</span>
<span class="sd">   :param str MODEL_PATH = path to model directorium</span>
<span class="sd">   :param str device = torch device CPU or CUDA</span>

<span class="sd">   How to use: model=load_trained_model(MODEL_PATH, device)</span>
<span class="sd">   &quot;&quot;&quot;</span>
</pre></div>
</div>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">get_criteria</span><span class="p">():</span>
<span class="w">   </span><span class="sd">&quot;&quot;&quot;</span>

<span class="sd">   -- Gives the criterion and mse_metric</span>


<span class="sd">   How to use: criterion, mseMetric=get_criteria()</span>
<span class="sd">   &quot;&quot;&quot;</span>
</pre></div>
</div>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">remove_padded_values_and_filter</span><span class="p">(</span><span class="n">folder_path</span><span class="p">):</span>
<span class="w">   </span><span class="sd">&quot;&quot;&quot;</span>

<span class="sd">   -- Preparing data for plotting. It&#39;ll remove the padded values from lc and it&#39;ll delete artifitially added lc with plus and minus errors. If your lc are not padded it&#39;ll only delete additional curves</span>


<span class="sd">   Args:</span>
<span class="sd">   :param str folder_path: Path to folder where the curves are. In this case it&#39;ll be &#39;./dataset/test&#39; or &#39;./dataset/train&#39; or &#39;./dataset/val&#39;</span>

<span class="sd">   How to use:</span>
<span class="sd">   if __name__ == &quot;__main__&quot;:</span>
<span class="sd">   folder_path = &quot;./dataset/test&quot;  # Change this to your dataset folder</span>

<span class="sd">   remove_padded_values_and_filter(folder_path)</span>
<span class="sd">   &quot;&quot;&quot;</span>
</pre></div>
</div>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">load_trcoeff</span><span class="p">():</span>
<span class="w">   </span><span class="sd">&quot;&quot;&quot;</span>

<span class="sd">   -- loading the original coefficients from pickle file</span>


<span class="sd">   How to use: tr=load_trcoeff()</span>

<span class="sd">   &quot;&quot;&quot;</span>
</pre></div>
</div>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">plot_function2</span><span class="p">(</span><span class="n">tr</span><span class="p">,</span><span class="n">target_x</span><span class="p">,</span> <span class="n">target_y</span><span class="p">,</span> <span class="n">context_x</span><span class="p">,</span> <span class="n">context_y</span><span class="p">,</span> <span class="n">yerr1</span><span class="p">,</span> <span class="n">pred_y</span><span class="p">,</span> <span class="n">var</span><span class="p">,</span> <span class="n">target_test_x</span><span class="p">,</span> <span class="n">lcName</span><span class="p">,</span> <span class="n">save</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">isTrainData</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">flagval</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">notTrainData</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
<span class="w">   </span><span class="sd">&quot;&quot;&quot;</span>

<span class="sd">   -- function for ploting the light curves</span>


<span class="sd">   context_x: Array of shape BATCH_SIZE x NUM_CONTEXT that contains the x values of the context points.</span>
<span class="sd">   context_y: Array of shape BATCH_SIZE x NUM_CONTEXT that contains the y values of the context points.</span>
<span class="sd">   target_x: Array of shape BATCH_SIZE x NUM_TARGET that contains the x values of the target points.</span>
<span class="sd">   target_y: Array of shape BATCH_SIZE x NUM_TARGET that contains the ground truth y values of the target points.</span>
<span class="sd">   target_test_x: Array of shape BATCH_SIZE x 400 that contains uniformly spread points across in [-2, 2] range.</span>
<span class="sd">   yerr1: Array of shape BATCH_SIZE x NUM_measurement_error that contains the measurement errors.</span>
<span class="sd">   pred_y: Array of shape BATCH_SIZE x 400 that contains predictions across [-2, 2] range.</span>
<span class="sd">   var: An array of shape BATCH_SIZE x 400  that contains the variance of predictions at target_test_x points.</span>
<span class="sd">   tr: array of data in pickle format needed to backtransform data from [-2,2] x [-2,2] to MJD x Mag</span>
<span class="sd">   &quot;&quot;&quot;</span>
</pre></div>
</div>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">load_test_data</span><span class="p">(</span><span class="n">data_path</span><span class="p">):</span>
<span class="w">   </span><span class="sd">&quot;&quot;&quot;</span>

<span class="sd">   -- takes data_path as an argument, creates a LighCurvesDataset and returns a PyTorch DataLoader for the test set. The DataLoader is used to load and preprocess the test data in batches</span>

<span class="sd">   Args:</span>
<span class="sd">   :param str data_path: path to Test data</span>

<span class="sd">   How to use: testLoader=load_test_data(DATA_PATH_TEST)</span>

<span class="sd">   &quot;&quot;&quot;</span>
</pre></div>
</div>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">load_train_data</span><span class="p">(</span><span class="n">data_path</span><span class="p">):</span>
<span class="w">   </span><span class="sd">&quot;&quot;&quot;</span>

<span class="sd">   -- takes data_path as an argument, creates a LighCurvesDataset and returns a PyTorch DataLoader for the test set. The DataLoader is used to load and preprocess the test data in batches</span>

<span class="sd">   Args:</span>
<span class="sd">   :param str data_path: path to train data</span>

<span class="sd">    How to use: trainLoader=load_train_data(DATA_PATH_TRAIN)</span>

<span class="sd">   &quot;&quot;&quot;</span>
</pre></div>
</div>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">load_val_data</span><span class="p">(</span><span class="n">data_path</span><span class="p">):</span>
<span class="w">   </span><span class="sd">&quot;&quot;&quot;</span>

<span class="sd">   -- takes data_path as an argument, creates a LighCurvesDataset and returns a PyTorch DataLoader for the test set. The DataLoader is used to load and preprocess the test data in batches</span>

<span class="sd">   Args:</span>
<span class="sd">   :param str data_path: path to VAL data</span>

<span class="sd">    How to use: valLoader=load_val_data(DATA_PATH_VAL)</span>

<span class="sd">   &quot;&quot;&quot;</span>
</pre></div>
</div>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">plot_test_data</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">testLoader</span><span class="p">,</span> <span class="n">criterion</span><span class="p">,</span> <span class="n">mseMetric</span><span class="p">,</span> <span class="n">plot_function</span><span class="p">,</span> <span class="n">device</span><span class="p">,</span> <span class="n">tr</span><span class="p">):</span>
<span class="w">   </span><span class="sd">&quot;&quot;&quot;</span>

<span class="sd">   -- Ploting the light curves from test set in original mjd range</span>


<span class="sd">     Args:</span>
<span class="sd">   :param model: Deterministic model</span>
<span class="sd">   :param testLoader: Uploaded test data</span>
<span class="sd">   :param criterion: criterion</span>
<span class="sd">   :param mseMetric: Mse Metric</span>
<span class="sd">   :param plot_function: plot function defined above</span>
<span class="sd">   :param device: torch device CPU or CUDA</span>
<span class="sd">   :param tr: trcoeff from pickle file</span>

<span class="sd">   How  to use: testMetrics=plot_test_data(model, testLoader, criterion, mseMetric, plot_function2, device, tr)</span>
<span class="sd">   &quot;&quot;&quot;</span>
</pre></div>
</div>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">save_test_metrics</span><span class="p">(</span><span class="n">OUTPUT_PATH</span><span class="p">,</span> <span class="n">testMetrics</span><span class="p">):</span>
<span class="w">   </span><span class="sd">&quot;&quot;&quot;</span>

<span class="sd">   -- saving the test metrics as json file</span>


<span class="sd">   Args:</span>
<span class="sd">   :param str OUTPUT_PATH: path to output folder</span>
<span class="sd">   :param testMetrics: returned data from ploting function</span>

<span class="sd">   How to use: save_test_metrics(OUTPUT_PATH, testMetrics)</span>
<span class="sd">   &quot;&quot;&quot;</span>
</pre></div>
</div>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">plot_train_light_curves</span><span class="p">(</span><span class="n">trainLoader</span><span class="p">,</span> <span class="n">model</span><span class="p">,</span> <span class="n">criterion</span><span class="p">,</span> <span class="n">mseMetric</span><span class="p">,</span> <span class="n">plot_function</span><span class="p">,</span> <span class="n">device</span><span class="p">,</span> <span class="n">tr</span><span class="p">):</span>
<span class="w">   </span><span class="sd">&quot;&quot;&quot;</span>

<span class="sd">   -- Ploting the light curves from train set in original mjd range</span>


<span class="sd">   Args:</span>
<span class="sd">   :param model: Deterministic model</span>
<span class="sd">   :param trainLoader: Uploaded trained data</span>
<span class="sd">   :param criterion: criterion</span>
<span class="sd">   :param mseMetric: Mse Metric</span>
<span class="sd">   :param plot_function: plot function defined above</span>
<span class="sd">   :param device: torch device CPU or CUDA</span>
<span class="sd">   :param tr: trcoeff from pickle file</span>

<span class="sd">   How to use: trainMetrics=plot_train_light_curves(trainLoader, model, criterion, mseMetric, plot_function2, device,tr)</span>
<span class="sd">   &quot;&quot;&quot;</span>
</pre></div>
</div>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">save_train_metrics</span><span class="p">(</span><span class="n">OUTPUT_PATH</span><span class="p">,</span> <span class="n">testMetrics</span><span class="p">):</span>
<span class="w">   </span><span class="sd">&quot;&quot;&quot;</span>

<span class="sd">   -- saving the train metrics as json file</span>


<span class="sd">    Args:</span>
<span class="sd">   :param str OUTPUT_PATH: path to output folder</span>
<span class="sd">   :param trainMetrics: returned data from ploting function</span>

<span class="sd">   How to use: save_train_metrics(OUTPUT_PATH, trainMetrics)</span>
<span class="sd">   &quot;&quot;&quot;</span>
</pre></div>
</div>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">plot_val_curves</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">valLoader</span><span class="p">,</span> <span class="n">criterion</span><span class="p">,</span> <span class="n">mseMetric</span><span class="p">,</span> <span class="n">plot_function</span><span class="p">,</span> <span class="n">device</span><span class="p">,</span> <span class="n">tr</span><span class="p">):</span>
<span class="w">   </span><span class="sd">&quot;&quot;&quot;</span>

<span class="sd">   -- Ploting the light curves from val set in original mjd range</span>


<span class="sd">   Args:</span>
<span class="sd">   :param model: Deterministic model</span>
<span class="sd">   :param valLoader: Uploaded val data</span>
<span class="sd">   :param criterion: criterion</span>
<span class="sd">   :param mseMetric: Mse Metric</span>
<span class="sd">   :param plot_function: plot function defined above</span>
<span class="sd">   :param device: torch device CPU or CUDA</span>
<span class="sd">   :param tr: trcoeff from pikle file</span>

<span class="sd">   How to use: valMetrics=plot_val_curves(model, valLoader, criterion, mseMetric, plot_function2, device,tr)</span>
<span class="sd">   &quot;&quot;&quot;</span>
</pre></div>
</div>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">save_val_metrics</span><span class="p">(</span><span class="n">OUTPUT_PATH</span><span class="p">,</span> <span class="n">valMetrics</span><span class="p">):</span>
<span class="w">   </span><span class="sd">&quot;&quot;&quot;</span>

<span class="sd">   -- saving the val metrics as json file</span>


<span class="sd">   Args:</span>
<span class="sd">   :param str OUTPUT_PATH: path to output folder</span>
<span class="sd">   valMetrics: returned data from ploting function</span>

<span class="sd">   How to use: save_val_metrics(OUTPUT_PATH, valMetrics)</span>
<span class="sd">   &quot;&quot;&quot;</span>
</pre></div>
</div>
</div></blockquote>
</div></blockquote>
<ol class="arabic simple" start="6">
<li><p><strong>PREDICTION AND PLOTTING THE DATA IN ORIGINAL DATA RANGE, IN ONE PDF FILE</strong></p></li>
</ol>
<blockquote>
<div><p><strong>`PREDICTION_onePDF_original_mjd.py`</strong></p>
<p>We use this module to predict and plot the model in the original range of data. All curves are plotted in one PDF file. This module contains the following functions that must be executed in order.</p>
<p>Before running this script, you must create the following folders in the directory where your Python notebook is located:</p>
<ol class="arabic simple">
<li><p><cite>./output/predictions/train/plots</cite> – folder for saving training plots</p></li>
<li><p><cite>./output/predictions/test/plots</cite> – folder for saving test plots</p></li>
<li><p><cite>./output/predictions/val/plots</cite> – folder for saving validation plots</p></li>
<li><p><cite>./output/predictions/train/data</cite> – folder for sving train data</p></li>
<li><p><cite>./output/predictions/test/data</cite> – folder for saving test data</p></li>
<li><p><cite>./output/predictions/val/data</cite> – folder for saving val data</p></li>
</ol>
<blockquote>
<div><div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">clear_output_dir</span><span class="p">(</span><span class="n">output_path</span><span class="p">):</span>
<span class="w">   </span><span class="sd">&quot;&quot;&quot;</span>

<span class="sd">   -- Removes all files in the specified output directory.</span>


<span class="sd">   Args:</span>
<span class="sd">   :param str output_path: The path to the output directory.</span>

<span class="sd">   How to use: clear_output_dir(OUTPUT_PATH)</span>

<span class="sd">   &quot;&quot;&quot;</span>
</pre></div>
</div>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">load_trained_model</span><span class="p">(</span><span class="n">MODEL_PATH</span><span class="p">,</span> <span class="n">device</span><span class="p">):</span>
<span class="w">   </span><span class="sd">&quot;&quot;&quot;</span>

<span class="sd">   --Uploading trained model</span>


<span class="sd">     agrs:</span>
<span class="sd">   :param str MODEL_PATH = path to model directorium</span>
<span class="sd">   :param str device = torch device CPU or CUDA</span>

<span class="sd">   How to use: model=load_trained_model(MODEL_PATH, device)</span>
<span class="sd">   &quot;&quot;&quot;</span>
</pre></div>
</div>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">get_criteria</span><span class="p">():</span>
<span class="w">   </span><span class="sd">&quot;&quot;&quot;</span>

<span class="sd">   -- Gives the criterion and mse_metric</span>


<span class="sd">   How to use: criterion, mseMetric=get_criteria()</span>
<span class="sd">   &quot;&quot;&quot;</span>
</pre></div>
</div>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">remove_padded_values_and_filter</span><span class="p">(</span><span class="n">folder_path</span><span class="p">):</span>
<span class="w">   </span><span class="sd">&quot;&quot;&quot;</span>

<span class="sd">   -- Preparing data for plotting. It&#39;ll remove the padded values from lc and it&#39;ll delete artifitially added lc with plus and minus errors. If your lc are not padded it&#39;ll only delete additional curves</span>


<span class="sd">   Args:</span>
<span class="sd">   :param str folder_path: Path to folder where the curves are. In this case it&#39;ll be &#39;./dataset/test&#39; or &#39;./dataset/train&#39; or &#39;./dataset/val&#39;</span>

<span class="sd">   How to use:</span>
<span class="sd">   if __name__ == &quot;__main__&quot;:</span>
<span class="sd">   folder_path = &quot;./dataset/test&quot;  # Change this to your dataset folder</span>

<span class="sd">   remove_padded_values_and_filter(folder_path)</span>
<span class="sd">   &quot;&quot;&quot;</span>
</pre></div>
</div>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">load_trcoeff</span><span class="p">():</span>
<span class="w">   </span><span class="sd">&quot;&quot;&quot;</span>

<span class="sd">   -- loading the original coefficients from pickle file</span>


<span class="sd">   How to use: tr=load_trcoeff()</span>

<span class="sd">   &quot;&quot;&quot;</span>
</pre></div>
</div>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">plot_function2</span><span class="p">(</span><span class="n">tr</span><span class="p">,</span><span class="n">target_x</span><span class="p">,</span> <span class="n">target_y</span><span class="p">,</span> <span class="n">context_x</span><span class="p">,</span> <span class="n">context_y</span><span class="p">,</span> <span class="n">yerr1</span><span class="p">,</span> <span class="n">pred_y</span><span class="p">,</span> <span class="n">var</span><span class="p">,</span> <span class="n">target_test_x</span><span class="p">,</span> <span class="n">lcName</span><span class="p">,</span> <span class="n">save</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">isTrainData</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">flagval</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">notTrainData</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
<span class="w">   </span><span class="sd">&quot;&quot;&quot;</span>

<span class="sd">   -- function for ploting the light curves. It needs to be uploaded separately</span>


<span class="sd">   context_x: Array of shape BATCH_SIZE x NUM_CONTEXT that contains the x values of the context points.</span>
<span class="sd">   context_y: Array of shape BATCH_SIZE x NUM_CONTEXT that contains the y values of the context points.</span>
<span class="sd">   target_x: Array of shape BATCH_SIZE x NUM_TARGET that contains the x values of the target points.</span>
<span class="sd">   target_y: Array of shape BATCH_SIZE x NUM_TARGET that contains the ground truth y values of the target points.</span>
<span class="sd">   target_test_x: Array of shape BATCH_SIZE x 400 that contains uniformly spread points across in [-2, 2] range.</span>
<span class="sd">   yerr1: Array of shape BATCH_SIZE x NUM_measurement_error that contains the measurement errors.</span>
<span class="sd">   pred_y: Array of shape BATCH_SIZE x 400 that contains predictions across [-2, 2] range.</span>
<span class="sd">   var: An array of shape BATCH_SIZE x 400  that contains the variance of predictions at target_test_x points.</span>
<span class="sd">   tr: array of data in pickle format needed to backtransform data from [-2,2] x [-2,2] to MJD x Mag</span>
<span class="sd">   &quot;&quot;&quot;</span>
</pre></div>
</div>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">load_test_data</span><span class="p">(</span><span class="n">data_path</span><span class="p">):</span>
<span class="w">   </span><span class="sd">&quot;&quot;&quot;</span>

<span class="sd">   -- takes data_path as an argument, creates a LighCurvesDataset and returns a PyTorch DataLoader for the test set. The DataLoader is used to load and preprocess the test data in batches</span>

<span class="sd">   Args:</span>
<span class="sd">   :param str data_path: path to Test data</span>

<span class="sd">   How to use: testLoader=load_test_data(DATA_PATH_TEST)</span>

<span class="sd">   &quot;&quot;&quot;</span>
</pre></div>
</div>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">load_train_data</span><span class="p">(</span><span class="n">data_path</span><span class="p">):</span>
<span class="w">   </span><span class="sd">&quot;&quot;&quot;</span>

<span class="sd">   -- takes data_path as an argument, creates a LighCurvesDataset and returns a PyTorch DataLoader for the test set. The DataLoader is used to load and preprocess the test data in batches</span>

<span class="sd">   Args:</span>
<span class="sd">   :param str data_path: path to train data</span>

<span class="sd">    How to use: trainLoader=load_train_data(DATA_PATH_TRAIN)</span>

<span class="sd">   &quot;&quot;&quot;</span>
</pre></div>
</div>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">load_val_data</span><span class="p">(</span><span class="n">data_path</span><span class="p">):</span>
<span class="w">   </span><span class="sd">&quot;&quot;&quot;</span>

<span class="sd">   -- takes data_path as an argument, creates a LighCurvesDataset and returns a PyTorch DataLoader for the test set. The DataLoader is used to load and preprocess the test data in batches</span>

<span class="sd">   Args:</span>
<span class="sd">   :param str data_path: path to VAL data</span>

<span class="sd">    How to use: valLoader=load_val_data(DATA_PATH_VAL)</span>

<span class="sd">   &quot;&quot;&quot;</span>
</pre></div>
</div>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">plot_test_light_curves</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">testLoader</span><span class="p">,</span> <span class="n">criterion</span><span class="p">,</span> <span class="n">mseMetric</span><span class="p">,</span> <span class="n">plot_function2</span><span class="p">,</span> <span class="n">device</span><span class="p">,</span><span class="n">tr</span><span class="p">):</span>
<span class="w">   </span><span class="sd">&quot;&quot;&quot;</span>

<span class="sd">   -- ploting the test set in original range</span>


<span class="sd">   Args:</span>
<span class="sd">   :param model: model</span>
<span class="sd">   :param testLoader: Test set</span>
<span class="sd">   :param criterion: criterion</span>
<span class="sd">   :param mseMetric: mse Metric</span>
<span class="sd">   :param plot_function2: defined above</span>
<span class="sd">   :param device: Torch device, CPU or CUDA</span>
<span class="sd">   :param tr: trcoeff from pickle file</span>

<span class="sd">   how to use: testMetrics=plot_test_light_curves(model, testLoader, criterion, mseMetric, plot_function2, device,tr)</span>
<span class="sd">   &quot;&quot;&quot;</span>
</pre></div>
</div>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">save_test_metrics</span><span class="p">(</span><span class="n">OUTPUT_PATH</span><span class="p">,</span> <span class="n">testMetrics</span><span class="p">):</span>
<span class="w">   </span><span class="sd">&quot;&quot;&quot;</span>

<span class="sd">   -- saving the test metrics as json file</span>


<span class="sd">   Args:</span>
<span class="sd">   :param str OUTPUT_PATH: path to output folder</span>
<span class="sd">    testMetrics: returned data from ploting function</span>

<span class="sd">   How to use: save_test_metrics(OUTPUT_PATH, testMetrics)</span>
<span class="sd">   &quot;&quot;&quot;</span>
</pre></div>
</div>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">plot_train_light_curves</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">trainLoader</span><span class="p">,</span> <span class="n">criterion</span><span class="p">,</span> <span class="n">mseMetric</span><span class="p">,</span> <span class="n">plot_function2</span><span class="p">,</span> <span class="n">device</span><span class="p">,</span><span class="n">tr</span><span class="p">):</span>
<span class="w">   </span><span class="sd">&quot;&quot;&quot;</span>

<span class="sd">   -- Ploting the light curves from train set in original mjd range</span>


<span class="sd">   Args:</span>
<span class="sd">   :param model: Deterministic model</span>
<span class="sd">   :param trainLoader: Uploaded trained data</span>
<span class="sd">   :param criterion: criterion</span>
<span class="sd">   :param mseMetric: Mse Metric</span>
<span class="sd">   :param plot_function: plot function defined above</span>
<span class="sd">   :param device: torch device CPU or CUDA</span>
<span class="sd">   :param tr: trcoeff from pickle file</span>

<span class="sd">   How to use: trainMetrics=plot_train_light_curves(model, trainLoader, criterion, mseMetric, plot_function2, device,tr)</span>
<span class="sd">   &quot;&quot;&quot;</span>
</pre></div>
</div>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">save_train_metrics</span><span class="p">(</span><span class="n">OUTPUT_PATH</span><span class="p">,</span> <span class="n">testMetrics</span><span class="p">):</span>
<span class="w">   </span><span class="sd">&quot;&quot;&quot;</span>

<span class="sd">   -- saving the train metrics as json file</span>


<span class="sd">   Args:</span>
<span class="sd">   :param str OUTPUT_PATH: path to output folder</span>
<span class="sd">   :param trainMetrics: returned data from ploting function</span>

<span class="sd">   How to use: save_train_metrics(OUTPUT_PATH, trainMetrics)</span>
<span class="sd">   &quot;&quot;&quot;</span>
</pre></div>
</div>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">plot_val_light_curves</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">valLoader</span><span class="p">,</span> <span class="n">criterion</span><span class="p">,</span> <span class="n">mseMetric</span><span class="p">,</span> <span class="n">plot_function2</span><span class="p">,</span> <span class="n">device</span><span class="p">,</span><span class="n">tr</span><span class="p">):</span>
<span class="w">   </span><span class="sd">&quot;&quot;&quot;</span>

<span class="sd">   -- Ploting the light curves from val set in original mjd range</span>


<span class="sd">   Args:</span>
<span class="sd">   :param model: Deterministic model</span>
<span class="sd">   :param valLoader: Uploaded val data</span>
<span class="sd">   :param criterion: criterion</span>
<span class="sd">   :param mseMetric: Mse Metric</span>
<span class="sd">   :param plot_function: plot function defined above</span>
<span class="sd">   :param device: torch device CPU or CUDA</span>
<span class="sd">   :param tr: trcoeff from pickle file</span>

<span class="sd">   How to use: valMetrics=plot_val_light_curves(model, valLoader, criterion, mseMetric, plot_function2, device,tr)</span>
<span class="sd">   &quot;&quot;&quot;</span>
</pre></div>
</div>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">save_val_metrics</span><span class="p">(</span><span class="n">OUTPUT_PATH</span><span class="p">,</span> <span class="n">valMetrics</span><span class="p">):</span>
<span class="w">   </span><span class="sd">&quot;&quot;&quot;</span>

<span class="sd">   -- saving the val metrics as json file</span>


<span class="sd">   Args:</span>
<span class="sd">   :param str OUTPUT_PATH: path to output folder</span>
<span class="sd">   :param valMetrics: returned data from ploting function</span>

<span class="sd">   How to use: save_val_metrics(OUTPUT_PATH, valMetrics)</span>
<span class="sd">   &quot;&quot;&quot;</span>
</pre></div>
</div>
</div></blockquote>
</div></blockquote>
</div></blockquote>
</section>
<section id="frequently-asked-questions">
<h1>Frequently Asked Questions<a class="headerlink" href="#frequently-asked-questions" title="Permalink to this heading"></a></h1>
<p><strong>Q</strong> What should my input data look like?</p>
<p>A: The input data should have three columns: mjd - Modified Julian Date or time, mag - magnitude, and magerr - magnitude error</p>
<p><strong>Q</strong> Do I need to run all four prediction modules?</p>
<p>A: No, it is enough to run only one prediction module, depending on what you want on the final plots. There are four options for prediction and plotting namely:</p>
<ol class="arabic simple">
<li><p>all curves are plotted separately and plots contain transformed data.</p></li>
<li><p>all curves are plotted in one pdf document and contain transformed data</p></li>
<li><p>all curves are plotted separately and the plots contain the original data.</p></li>
<li><p>all curves are plotted in one pdf document and contain original data</p></li>
</ol>
<p><strong>Q</strong> Can the package be used for other uses outside of astronomy?</p>
<p>A: Yes, the package can be used for different types of time series analysis.</p>
</section>
<section id="licence">
<h1>Licence<a class="headerlink" href="#licence" title="Permalink to this heading"></a></h1>
<p>MIT License</p>
<p>Copyright (c) 2024 Andjelka Kovacevic, Marina Pavlovic, Aman Raju, Nikola Mitrovic - Andric, Iva Cvorovic - Hajdinjak, Dragana Ilic, SER-SAG in-kind team from Serbia</p>
<p>Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the “Software”), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:</p>
<p>The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.</p>
<p>THE SOFTWARE IS PROVIDED “AS IS”, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.</p>
</section>
<section id="sphinx-documentation">
<h1>SPHINX_DOCUMENTATION<a class="headerlink" href="#sphinx-documentation" title="Permalink to this heading"></a></h1>
<div class="toctree-wrapper compound">
</div>
</section>
<section id="qnpy-package">
<h1>QNPy package<a class="headerlink" href="#qnpy-package" title="Permalink to this heading"></a></h1>
<section id="submodules">
<h2>Submodules<a class="headerlink" href="#submodules" title="Permalink to this heading"></a></h2>
</section>
<section id="module-QNPy.CNP_ARCHITECTURE">
<span id="qnpy-cnp-architecture-module"></span><h2>QNPy.CNP_ARCHITECTURE module<a class="headerlink" href="#module-QNPy.CNP_ARCHITECTURE" title="Permalink to this heading"></a></h2>
<dl class="py class">
<dt class="sig sig-object py" id="QNPy.CNP_ARCHITECTURE.DeterministicDecoder">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">QNPy.CNP_ARCHITECTURE.</span></span><span class="sig-name descname"><span class="pre">DeterministicDecoder</span></span><a class="headerlink" href="#QNPy.CNP_ARCHITECTURE.DeterministicDecoder" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">Module</span></code></p>
<p>The Decoder.</p>
<dl class="py method">
<dt class="sig sig-object py" id="QNPy.CNP_ARCHITECTURE.DeterministicDecoder.forward">
<span class="sig-name descname"><span class="pre">forward</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">representation</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">target_x</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#QNPy.CNP_ARCHITECTURE.DeterministicDecoder.forward" title="Permalink to this definition"></a></dt>
<dd><p>Decodes the individual targets.</p>
<dl class="simple">
<dt>Args:</dt><dd><p>representation: The encoded representation of the context
target_x: The x locations for the target query</p>
</dd>
<dt>Returns:</dt><dd><p>dist: A multivariate Gaussian over the target points.
mu: The mean of the multivariate Gaussian.
sigma: The standard deviation of the multivariate Gaussian.</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="QNPy.CNP_ARCHITECTURE.DeterministicEncoder">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">QNPy.CNP_ARCHITECTURE.</span></span><span class="sig-name descname"><span class="pre">DeterministicEncoder</span></span><a class="headerlink" href="#QNPy.CNP_ARCHITECTURE.DeterministicEncoder" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">Module</span></code></p>
<p>The Encoder.</p>
<dl class="py method">
<dt class="sig sig-object py" id="QNPy.CNP_ARCHITECTURE.DeterministicEncoder.forward">
<span class="sig-name descname"><span class="pre">forward</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">context_x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">context_y</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#QNPy.CNP_ARCHITECTURE.DeterministicEncoder.forward" title="Permalink to this definition"></a></dt>
<dd><p>Encodes the inputs into one representation.</p>
<dl class="simple">
<dt>Args:</dt><dd><p>context_x, context_y: Tensors of size BATCH_SIZE x NUM_OF_OBSERVATIONS</p>
</dd>
<dt>Returns:</dt><dd><p>representation: The encoded representation averaged over all context points.</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="QNPy.CNP_ARCHITECTURE.DeterministicModel">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">QNPy.CNP_ARCHITECTURE.</span></span><span class="sig-name descname"><span class="pre">DeterministicModel</span></span><a class="headerlink" href="#QNPy.CNP_ARCHITECTURE.DeterministicModel" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">Module</span></code></p>
<p>The CNP model.</p>
<dl class="py method">
<dt class="sig sig-object py" id="QNPy.CNP_ARCHITECTURE.DeterministicModel.forward">
<span class="sig-name descname"><span class="pre">forward</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">context_x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">context_y</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">target_x</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#QNPy.CNP_ARCHITECTURE.DeterministicModel.forward" title="Permalink to this definition"></a></dt>
<dd><p>Returns the predicted mean and variance at the target points.</p>
<dl class="simple">
<dt>Args:</dt><dd><p>context_x: Array of shape BATCH_SIZE x NUM_CONTEXT that contains the x values of the context points.
context_y: Array of shape BATCH_SIZE x NUM_CONTEXT that contains the y values of the context points.
target_x: Array of shape BATCH_SIZE x NUM_TARGET that contains the x values of the target points.</p>
</dd>
<dt>Returns:</dt><dd><p>dist: A multivariate Gaussian over the target points.
mu: The mean of the multivariate Gaussian.
sigma: The standard deviation of the multivariate Gaussian.</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</section>
<section id="module-QNPy.CNP_DATASETCLASS">
<span id="qnpy-cnp-datasetclass-module"></span><h2>QNPy.CNP_DATASETCLASS module<a class="headerlink" href="#module-QNPy.CNP_DATASETCLASS" title="Permalink to this heading"></a></h2>
<dl class="py class">
<dt class="sig sig-object py" id="QNPy.CNP_DATASETCLASS.LighCurvesDataset">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">QNPy.CNP_DATASETCLASS.</span></span><span class="sig-name descname"><span class="pre">LighCurvesDataset</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">root_dir</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">status</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#QNPy.CNP_DATASETCLASS.LighCurvesDataset" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">Dataset</span></code></p>
<p>Dataset class.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="QNPy.CNP_DATASETCLASS.collate_lcs">
<span class="sig-prename descclassname"><span class="pre">QNPy.CNP_DATASETCLASS.</span></span><span class="sig-name descname"><span class="pre">collate_lcs</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">batch</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#QNPy.CNP_DATASETCLASS.collate_lcs" title="Permalink to this definition"></a></dt>
<dd><p>Custom collate function for padding and stacking tensors in a batch.</p>
<dl>
<dt>Args:</dt><dd><blockquote>
<div><dl class="simple">
<dt>batch: List containing variable length tensors where each item represents data for one light curve</dt><dd><dl class="simple">
<dt>data = {‘lcName’<span class="classifier">lcName,</span></dt><dd><p>‘context_x’: context_x,
‘context_y’: context_y,
‘target_x’: target_x,
‘target_y’: target_y,
‘measurement_error’: z_data}</p>
</dd>
</dl>
</dd>
</dl>
</div></blockquote>
<dl class="simple">
<dt>Returns:</dt><dd><p>[context_x, context_y, target_x], target_y: Padded and stacked tensors.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</section>
<section id="module-QNPy.CNP_METRICS">
<span id="qnpy-cnp-metrics-module"></span><h2>QNPy.CNP_METRICS module<a class="headerlink" href="#module-QNPy.CNP_METRICS" title="Permalink to this heading"></a></h2>
<dl class="py class">
<dt class="sig sig-object py" id="QNPy.CNP_METRICS.LogProbLoss">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">QNPy.CNP_METRICS.</span></span><span class="sig-name descname"><span class="pre">LogProbLoss</span></span><a class="headerlink" href="#QNPy.CNP_METRICS.LogProbLoss" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">Module</span></code></p>
<p>Log probability loss function.</p>
<dl class="py method">
<dt class="sig sig-object py" id="QNPy.CNP_METRICS.LogProbLoss.forward">
<span class="sig-name descname"><span class="pre">forward</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dist</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">target_y</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#QNPy.CNP_METRICS.LogProbLoss.forward" title="Permalink to this definition"></a></dt>
<dd><p>Returns the loss value.</p>
<dl class="simple">
<dt>Args:</dt><dd><p>dist: A multivariate Gaussian over the target points.
target_y: Array of shape BATCH_SIZE x NUM_TARGET that contains the ground truth y values of the target points.</p>
</dd>
<dt>Returns:</dt><dd><p>loss: Mean over log probabilities.</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="QNPy.CNP_METRICS.MAELoss">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">QNPy.CNP_METRICS.</span></span><span class="sig-name descname"><span class="pre">MAELoss</span></span><a class="headerlink" href="#QNPy.CNP_METRICS.MAELoss" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">Module</span></code></p>
<p>MAE loss function.</p>
<dl class="py method">
<dt class="sig sig-object py" id="QNPy.CNP_METRICS.MAELoss.forward">
<span class="sig-name descname"><span class="pre">forward</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">y_true</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y_pred</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">weights</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#QNPy.CNP_METRICS.MAELoss.forward" title="Permalink to this definition"></a></dt>
<dd><p>Returns the MAE value.</p>
<dl class="simple">
<dt>Args:</dt><dd><p>y_true: Ground truth values.
y_pred: Predicted values.
weights: Measurement errors of ground truth values.</p>
</dd>
<dt>Returns:</dt><dd><p>mse: Mean squared error.</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="QNPy.CNP_METRICS.MSELoss">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">QNPy.CNP_METRICS.</span></span><span class="sig-name descname"><span class="pre">MSELoss</span></span><a class="headerlink" href="#QNPy.CNP_METRICS.MSELoss" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">Module</span></code></p>
<p>MSE loss function.</p>
<dl class="py method">
<dt class="sig sig-object py" id="QNPy.CNP_METRICS.MSELoss.forward">
<span class="sig-name descname"><span class="pre">forward</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">y_true</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y_pred</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">weights</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#QNPy.CNP_METRICS.MSELoss.forward" title="Permalink to this definition"></a></dt>
<dd><p>Returns the MSE value.</p>
<dl class="simple">
<dt>Args:</dt><dd><p>y_true: Ground truth values.
y_pred: Predicted values.
weights: Measurement errors of ground truth values.</p>
</dd>
<dt>Returns:</dt><dd><p>mse: Mean squared error.</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</section>
<section id="module-QNPy.Clustering_with_SOM">
<span id="qnpy-clustering-with-som-module"></span><h2>QNPy.Clustering_with_SOM module<a class="headerlink" href="#module-QNPy.Clustering_with_SOM" title="Permalink to this heading"></a></h2>
<dl class="py function">
<dt class="sig sig-object py" id="QNPy.Clustering_with_SOM.Assign_Cluster_Labels">
<span class="sig-prename descclassname"><span class="pre">QNPy.Clustering_with_SOM.</span></span><span class="sig-name descname"><span class="pre">Assign_Cluster_Labels</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">som_model</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">scaled_curves</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ids</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#QNPy.Clustering_with_SOM.Assign_Cluster_Labels" title="Permalink to this definition"></a></dt>
<dd><p>Assigns Cluster labels to each of the curves, making a dataframe with their ids</p>
<p>som_model:  
The trained SOM</p>
<p>scaled_curves: np.ndarray
The scaled curves that were used to train the SOM</p>
<p>ids: list
The ids of the curves</p>
<p>cluster_df: Dataframe
A map matching each of the cluster ids with the cluster they belong to</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="QNPy.Clustering_with_SOM.Averaging_Clusters">
<span class="sig-prename descclassname"><span class="pre">QNPy.Clustering_with_SOM.</span></span><span class="sig-name descname"><span class="pre">Averaging_Clusters</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">chosen_cluster</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cluster_map</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lcs</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">plot</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dba</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#QNPy.Clustering_with_SOM.Averaging_Clusters" title="Permalink to this definition"></a></dt>
<dd><p>Creating a representation of the chosen cluster with the light curves and the average light curve</p>
<p>chosen_cluster: int 
The cluster of interest</p>
<p>cluster_map: pd.Dataframe
A map of each of the ids to the clusters</p>
<p>lcs: list of list of pd.Dataframes
The light curves (provide the input from just one filter)</p>
<p>plot: bool
Whether to plot or just return the average value</p>
<p>dba: bool
Whether to use Dynamic Barymetric Time Averaging or to use a simple mean of the light curves</p>
<p>average_x:
The x_axis (i.e timesteps) of the average light curve</p>
<p>average_y:
The y_axis (i.e magnitudes) of the average light curve</p>
<p>x:
The timesteps of all the light curves concatenated into one array</p>
<p>y: 
The magnitudes of all the light curves concatenated into one array</p>
<p>len(x):
The length of all the light curves</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="QNPy.Clustering_with_SOM.Cluster_Metrics">
<span class="sig-prename descclassname"><span class="pre">QNPy.Clustering_with_SOM.</span></span><span class="sig-name descname"><span class="pre">Cluster_Metrics</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">scaled_curves</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cluster_map</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">metric</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'Silhoutte'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#QNPy.Clustering_with_SOM.Cluster_Metrics" title="Permalink to this definition"></a></dt>
<dd><p>Measures metrics related to the clustering</p>
<p>scaled_curves: np.ndarray
The scaled curves used to train the SOM</p>
<p>cluster_map: pd.Dataframe
A map of each of the ids to the clusters</p>
<p>metric: str
The metric to be measured. It can be Silhoutte, DBI or CH. This is for silhoutte score, Davies-Bouldin index and calinski-harabasz score</p>
<p>score:
The metric that is calculated</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="QNPy.Clustering_with_SOM.Cluster_Properties">
<span class="sig-prename descclassname"><span class="pre">QNPy.Clustering_with_SOM.</span></span><span class="sig-name descname"><span class="pre">Cluster_Properties</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">cluster_map</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">selected_cluster</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lcs</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">redshifts_map</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">plot</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">return_values</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">the_property</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'all'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">save_figs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">figs_save_path</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'./'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#QNPy.Clustering_with_SOM.Cluster_Properties" title="Permalink to this definition"></a></dt>
<dd><p>Getting the selected property of a chosen cluster</p>
<p>cluster_map: pd.Dataframe
A map of each of the ids to the clusters</p>
<p>chosen_cluster: int 
The cluster of interest</p>
<p>lcs: list of list of pd.Dataframes
The light curves (provide the input from just one filter)</p>
<p>redshifts_map: pd.Dataframe
The redshift associated with each source id</p>
<p>plot: bool
Whether to plot or just return the average value</p>
<p>return_values: bool
Whether to return the values for the property</p>
<p>the_property: str
The property to plot. Choice from z (redshift), Fvar (the variability function), Lum (luminosity), Mass, or all</p>
<p>save_figs: bool
Whether to save the figure or not</p>
<p>figs_save_path: str
Where to save the figure. Note that it is saved under a directory called Plots in that directory.</p>
<p>return_list: 
The list of the property of interest</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="QNPy.Clustering_with_SOM.Cluster_Properties_Comparison">
<span class="sig-prename descclassname"><span class="pre">QNPy.Clustering_with_SOM.</span></span><span class="sig-name descname"><span class="pre">Cluster_Properties_Comparison</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">cluster_map</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lcs</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">redshifts_map</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">the_property</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'Fvar'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">color</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'#1f77b4'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">figsize</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">(15,</span> <span class="pre">15)</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">save_figs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">figs_save_path</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'./'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#QNPy.Clustering_with_SOM.Cluster_Properties_Comparison" title="Permalink to this definition"></a></dt>
<dd><p>Plotting the property of interest for all the clusters onto one figure</p>
<p>cluster_map: pd.Dataframe
A map of each of the ids to the clusters</p>
<p>lcs: list of list of pd.Dataframes
The light curves (provide the input from just one filter)</p>
<p>redshifts_map: pd.Dataframe
The redshift associated with each source id</p>
<p>the_property: str
The property to plot. Choice from z (redshift), Fvar (the variability function), Lum (luminosity), Mass, or all</p>
<p>color: str
The color to make the histogram</p>
<p>figsize: tuple
The figure size</p>
<p>save_figs: bool
Whether to save the figure or not</p>
<p>figs_save_path: str
Where to save the figure. Note that it is saved under a directory called Plots in that directory.</p>
<p>return_list: 
The list of the property of interest</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="QNPy.Clustering_with_SOM.Get_Gradient_Cluster">
<span class="sig-prename descclassname"><span class="pre">QNPy.Clustering_with_SOM.</span></span><span class="sig-name descname"><span class="pre">Get_Gradient_Cluster</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">som</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#QNPy.Clustering_with_SOM.Get_Gradient_Cluster" title="Permalink to this definition"></a></dt>
<dd><p>Finds the center of the gradient for each node of the SOM</p>
<p>som: int  
The trained SOM</p>
<p>cluster_centers:
The center nodes that become the new gradient clusters</p>
<p>cluster_pos:
The original SOM cluster centers</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="QNPy.Clustering_with_SOM.Get_Gradient_Cluster_2D">
<span class="sig-prename descclassname"><span class="pre">QNPy.Clustering_with_SOM.</span></span><span class="sig-name descname"><span class="pre">Get_Gradient_Cluster_2D</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">som</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fill</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'mean'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">interpolation_kind</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'cubic'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#QNPy.Clustering_with_SOM.Get_Gradient_Cluster_2D" title="Permalink to this definition"></a></dt>
<dd><p>Finding the gradient clusters from the 2D SOM</p>
<p>som: 
The trained SOM</p>
<p>fill: str
‘mean’ or ‘interpolate’. Either the empty values are filled with the mean or they are interpolated with a function</p>
<p>interpolation_kind: 
Any of the scipy.interp1d interpolation kinds. Recommended to use cubic</p>
<p>cluster_centers:
The cluster centers</p>
<p>cluster_pos:
The cluster positions</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="QNPy.Clustering_with_SOM.Gradient_Cluster_Map">
<span class="sig-prename descclassname"><span class="pre">QNPy.Clustering_with_SOM.</span></span><span class="sig-name descname"><span class="pre">Gradient_Cluster_Map</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">som</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">scaled_curves</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ids</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dimension</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'1D'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fill</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'mean'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">interpolation_kind</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'cubic'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">clusters</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">som_x</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">som_y</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#QNPy.Clustering_with_SOM.Gradient_Cluster_Map" title="Permalink to this definition"></a></dt>
<dd><p>Translates the SOM nodes into larger clusters based on their gradients. Implementation of 
<a class="reference external" href="https://homepage.cs.uri.edu/faculty/hamel/pubs/improved-umat-dmin11.pdf">https://homepage.cs.uri.edu/faculty/hamel/pubs/improved-umat-dmin11.pdf</a></p>
<p>som_model:  
The trained SOM</p>
<p>scaled_curves: np.ndarray
The scaled curves used to train the SOM</p>
<p>ids: list
The ids of the curves</p>
<p>dimension: str
If 1D, does 1D clustering, else multivariate</p>
<p>fill: str
‘mean’ or ‘interpolate’. Either the empty values are filled with the mean or they are interpolated with a function</p>
<p>interpolation_kind: 
Any of the scipy.interp1d interpolation kinds. Recommended to use cubic</p>
<p>clusters:
The clusters that the ids are in (only for multi-variate)</p>
<p>som_x: int
The x-dimensions of the SOM</p>
<p>som_y: int
The y-dimensions of the SOM</p>
<p>cluster_map:
The new clusters that the ids are in</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="QNPy.Clustering_with_SOM.Load_Light_Curves">
<span class="sig-prename descclassname"><span class="pre">QNPy.Clustering_with_SOM.</span></span><span class="sig-name descname"><span class="pre">Load_Light_Curves</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">folder</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">one_filter</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">filters</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'a'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">id_list</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#QNPy.Clustering_with_SOM.Load_Light_Curves" title="Permalink to this definition"></a></dt>
<dd><p>Loads light curves from a specified folder. Can be used to load either multiple filters or just one filter</p>
<p>folder: str 
The folder where the light curves are stored</p>
<p>one_filter: bool
If set to true, the light curves are only stored in one folder without filters</p>
<p>filters: list or str(if each filter is a single letter)
The filters that are to be loaded. Each filter should have a subfolder named after it if there are more than one filters</p>
<p>id_list: list of str or None
The subset of IDs to load. If None, retrieves all files in the given folder. NOTE: make sure the ids are strings</p>
<p>light_curves: list of lists of dataframes
The list of light curves arranged by filter</p>
<p>ids: list
The ids of the light curves (Ensure that they are the same in all filters)</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="QNPy.Clustering_with_SOM.Normal_Cluster_to_Grad">
<span class="sig-prename descclassname"><span class="pre">QNPy.Clustering_with_SOM.</span></span><span class="sig-name descname"><span class="pre">Normal_Cluster_to_Grad</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">cluster_map</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">gradient_cluster_map</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#QNPy.Clustering_with_SOM.Normal_Cluster_to_Grad" title="Permalink to this definition"></a></dt>
<dd><p>Maps the normal cluster map to the gradient clusters</p>
<p>cluster_map: pd.DataFrame  
The map of the ids to the original SOM node clusters</p>
<p>gradient_cluster_map: pd.DataFrame  
The map of the ids to the gradient SOM node clusters</p>
<p>joint_map:
Mapping of each SOM node cluster to the gradient cluster</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="QNPy.Clustering_with_SOM.Pad_Light_Curves">
<span class="sig-prename descclassname"><span class="pre">QNPy.Clustering_with_SOM.</span></span><span class="sig-name descname"><span class="pre">Pad_Light_Curves</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">light_curves</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">minimum_length</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">100</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">save_padded_lcs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">padded_lcs_save_path</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'./'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ids</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#QNPy.Clustering_with_SOM.Pad_Light_Curves" title="Permalink to this definition"></a></dt>
<dd><p>Pads the light curves with the mean value at the end of the curve</p>
<p>light_curves: lists of dataframes 
The light curves stored in a list</p>
<p>minimum_length: int
The minimum length to pad to</p>
<p>save_padded_lcs: bool
If True, will save the light curves into a folder known as Padded_Lc in the specified directory</p>
<p>padded_lcs_save_path: str
The directory to save the light curves in</p>
<p>ids: list of str
A list of the ids. Must provided in order to save the light curves</p>
<p>light_curves: list of lists
The new padded light curves</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="QNPy.Clustering_with_SOM.Plot_All_Clusters">
<span class="sig-prename descclassname"><span class="pre">QNPy.Clustering_with_SOM.</span></span><span class="sig-name descname"><span class="pre">Plot_All_Clusters</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">cluster_map</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lcs</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">color</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'tab:blue'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dba</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">figsize</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">(10,</span> <span class="pre">10)</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">save_figs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">figs_save_path</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'./'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#QNPy.Clustering_with_SOM.Plot_All_Clusters" title="Permalink to this definition"></a></dt>
<dd><p>Plots all of the clusters on a magnitude plot with the average representation included</p>
<p>cluster_map: pd.Dataframe
A map of each of the ids to the clusters</p>
<p>lcs: list of list of pd.Dataframes
The light curves (provide the input from just one filter)</p>
<p>color: str
The color to plot the averaged curve in</p>
<p>dba: bool
Whether to use Dynamic Barymetric Time Averaging or to use a simple mean of the light curves</p>
<p>figsize: tuple
The figure size</p>
<p>save_figs: bool
Whether to save the figure or not</p>
<p>figs_save_path: str
Where to save the figure. Note that it is saved under a directory called Plots in that directory.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="QNPy.Clustering_with_SOM.Plot_Lc">
<span class="sig-prename descclassname"><span class="pre">QNPy.Clustering_with_SOM.</span></span><span class="sig-name descname"><span class="pre">Plot_Lc</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">Light_Curve</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">header</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'Light</span> <span class="pre">Curve'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">save_fig</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">filename</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'Figure'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">x_axis</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'mjd'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">return_fig</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#QNPy.Clustering_with_SOM.Plot_Lc" title="Permalink to this definition"></a></dt>
<dd><p>Plots light curves interactively. Adapted from <a class="reference external" href="https://github.com/DamirBogdan39/time-series-analysis/tree/main">https://github.com/DamirBogdan39/time-series-analysis/tree/main</a></p>
<p>Light_Curve: Dataframe 
The light curve to plot. Should be in a dataframe with mjd (or any x axis), mag and magerr</p>
<p>header: str
The header of the file</p>
<p>save_fig: bool
Whether to save the figure</p>
<p>filename: str
What to name the saved html file</p>
<p>x_axis: str
What to label the x axis</p>
<p>return_fig: bool
Whether the figure is returned</p>
<p>Figure:
The interactive plot of the light curve</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="QNPy.Clustering_with_SOM.Plot_SOM_Scaled_Average">
<span class="sig-prename descclassname"><span class="pre">QNPy.Clustering_with_SOM.</span></span><span class="sig-name descname"><span class="pre">Plot_SOM_Scaled_Average</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">som_model</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">scaled_curves</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dba</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">figsize</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">(10,</span> <span class="pre">10)</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">save_figs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">figs_save_path</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'./'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">plot_weights</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">plot_avg</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">plot_background</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">one_fig</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">show_fig</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#QNPy.Clustering_with_SOM.Plot_SOM_Scaled_Average" title="Permalink to this definition"></a></dt>
<dd><p>Plotting the SOM Clusters with the average light curve and the SOM weights of each cluster. The average can be either simple mean
or using a dba averaging method (<a class="reference external" href="https://github.com/fpetitjean/DBA">https://github.com/fpetitjean/DBA</a>)</p>
<p>som_model:  
The trained SOM</p>
<p>scaled_curves: np.ndarray
The scaled curves that were the input for training</p>
<p>dba: bool
Whether to use Dynamic Barymetric Time Averaging</p>
<p>figsize: tuple
The size of the figure</p>
<p>save_figs: bool
Whether to save the figure or not</p>
<p>fig_save_path: str
Where to save the figure. Note that it creates a directory called Plots in the location given.</p>
<p>plot_avg: bool
Whether to plot the mean light curve of the cluster</p>
<p>plot_weights: bool
Whether to plot the SOM weight of the cluster</p>
<p>plot_background: bool
Whether to plot the light curves that make up the cluster</p>
<p>one_fig: bool
Whether to plot all the clusters into one figure or seperate figures</p>
<p>show_fig: bool
Whether to show each of the plots in the seperate figures case</p>
<p>Plot:
The plots of the clusters</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="QNPy.Clustering_with_SOM.SF">
<span class="sig-prename descclassname"><span class="pre">QNPy.Clustering_with_SOM.</span></span><span class="sig-name descname"><span class="pre">SF</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">magnitudes</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#QNPy.Clustering_with_SOM.SF" title="Permalink to this definition"></a></dt>
<dd><p>Calculates the S function of given light curves. S is the variance of all magnitudes</p>
<p>lcs:  List of pd.Dataframes
The light curves of interest</p>
<p>sf:
The list of SFs</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="QNPy.Clustering_with_SOM.SFminus">
<span class="sig-prename descclassname"><span class="pre">QNPy.Clustering_with_SOM.</span></span><span class="sig-name descname"><span class="pre">SFminus</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">magnitudes</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#QNPy.Clustering_with_SOM.SFminus" title="Permalink to this definition"></a></dt>
<dd><p>Calculates the S- function of given light curves. S- is the variance of magnitudes where the brightness decreases</p>
<p>lcs:  List of pd.Dataframes
The light curves of interest</p>
<p>sfminus:
The list of S-</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="QNPy.Clustering_with_SOM.SFplus">
<span class="sig-prename descclassname"><span class="pre">QNPy.Clustering_with_SOM.</span></span><span class="sig-name descname"><span class="pre">SFplus</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">magnitudes</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#QNPy.Clustering_with_SOM.SFplus" title="Permalink to this definition"></a></dt>
<dd><p>Calculates the S+ function of given light curves. S+ is the variance of magnitudes where the brightness increases</p>
<p>lcs:  List of pd.Dataframes
The light curves of interest</p>
<p>sfplus:
The list of S+</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="QNPy.Clustering_with_SOM.SOM_1D">
<span class="sig-prename descclassname"><span class="pre">QNPy.Clustering_with_SOM.</span></span><span class="sig-name descname"><span class="pre">SOM_1D</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">scaled_curves</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">som_x</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">som_y</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">learning_rate</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sigma</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">topology</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'rectangular'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pca_init</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">neighborhood_function</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'gaussian'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">train_mode</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'random'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">batch_size</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">5</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">epochs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">50000</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">save_som</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">model_save_path</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'./'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">random_seed</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">21</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">stat</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'q'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">plot_frequency</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">100</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">early_stopping_no</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#QNPy.Clustering_with_SOM.SOM_1D" title="Permalink to this definition"></a></dt>
<dd><p>Training a SOM on ONE dimensional data (The magnitude of the light curves)
Parameters
———-
scaled_curves: list of dataframes 
The scaled light curves stored in a list.</p>
<p>som_x: int
The x size of the SOM. If None is given, make sure the som_y is None as well. Then, it chooses the recommended SOM 
size of sqrt(sqrt(length))</p>
<p>som_y: int
The y size of the SOM. If None is given, make sure the som_x is None as well. Then, it chooses the recommended SOM 
size of sqrt(sqrt(length))</p>
<p>learning_rate: float
How much the SOM learns from the new data that it sees</p>
<p>sigma: float
The effect each node has on its neighboring nodes</p>
<p>topology: ‘rectangular’ or ‘hexagonal’:
The topology of the SOM. Note that visualizations are mainly built for the rectangular at the moment.</p>
<p>pca_init: bool
Whether to initialize the SOM weights randomly or to initialize by PCA of the input data</p>
<p>neighborhood_function: str
Choose from ‘gaussian’,’mexican hat’,’bubble’, or ‘triangle’. These affect the influence of a node on its neighbors</p>
<p>train_mode:’random’ or ‘all’
When chosen random, it chooses a random curve each epoch. When trained on all, it batches the data and trains on every
light curve for a certain number of epochs.</p>
<p>batch_size: int
How big the batch is for the ‘all’ train mode. The smaller the batch size, the finer the progress bar displayed</p>
<p>epochs: int
This is defined in two ways. If the train_mode is random, then it is the number of iterations that the SOM runs on.
If it is all, then it is the number of times that the SOM trains on each input datapoint. Note that the lr and sigma
decay in each epoch.</p>
<p>save_som: bool
Whether to save the trained SOM</p>
<p>model_save_path:str
The file to save the SOM in</p>
<p>random_seed:int
The starting state of the random weights of the SOM. Use for reproducibility</p>
<p>stat: ‘q’,’t’, or ‘qt’
Whether to record the quantization error, topographical error or both. Note that calculating them is expensive</p>
<p>plot_frequency: int
The number of epochs</p>
<p>early_stopping_no: int or None
The number of batches to process before stopping. Use None if you should train on all</p>
<p>som_model:
The trained SOM that can be saved or used for analysis</p>
<p>q_error: list
The quantization errors recorded</p>
<p>t_error: list
The topographic errors recorded</p>
<p>indices_to_plot: list
The indices to plot for the quantization or/and topographic errors</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="QNPy.Clustering_with_SOM.SOM_Activation_Map">
<span class="sig-prename descclassname"><span class="pre">QNPy.Clustering_with_SOM.</span></span><span class="sig-name descname"><span class="pre">SOM_Activation_Map</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">som_model</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">figsize</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">(5,</span> <span class="pre">5)</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cmap</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'YlOrRd'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">save_figs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">figs_save_path</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'./'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#QNPy.Clustering_with_SOM.SOM_Activation_Map" title="Permalink to this definition"></a></dt>
<dd><p>Plots a heatmap of the SOM Nodes. The brighter, the more light curves activate the SOM</p>
<p>som_model:  
The trained SOM</p>
<p>cmap: str
The matplotlib based color scale to use for the plots</p>
<p>figsize: tuple
The size of the figure</p>
<p>save_figs: bool
Whether to save the figure or not</p>
<p>fig_save_path: str
Where to save the figure. Note that it creates a directory called Plots in the location given.</p>
<p>Plot:
The heatmap plot</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="QNPy.Clustering_with_SOM.SOM_Clusters_Histogram">
<span class="sig-prename descclassname"><span class="pre">QNPy.Clustering_with_SOM.</span></span><span class="sig-name descname"><span class="pre">SOM_Clusters_Histogram</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">cluster_map</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">color</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'tab:blue'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">save_figs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">figs_save_path</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'./'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">figsize</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">(5,</span> <span class="pre">5)</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#QNPy.Clustering_with_SOM.SOM_Clusters_Histogram" title="Permalink to this definition"></a></dt>
<dd><p>Plots a heatmap of the SOM Nodes. The brighter, the further away they are from their neighbors</p>
<p>cluster_map:  
The dataframe with each id and the cluster that it belongs to</p>
<p>color: str
The color to plot the histogram</p>
<p>save_figs: bool
Whether to save the figure or not</p>
<p>fig_save_path: str
Where to save the figure. Note that it creates a directory called Plots in the location given.</p>
<p>figsize: tuple
The size of the figure</p>
<p>Plot:
The Histogram of how many curves are in each cluster</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="QNPy.Clustering_with_SOM.SOM_Distance_Map">
<span class="sig-prename descclassname"><span class="pre">QNPy.Clustering_with_SOM.</span></span><span class="sig-name descname"><span class="pre">SOM_Distance_Map</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">som_model</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">figsize</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">(5,</span> <span class="pre">5)</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cmap</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'YlOrRd'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">save_figs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">figs_save_path</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'./'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#QNPy.Clustering_with_SOM.SOM_Distance_Map" title="Permalink to this definition"></a></dt>
<dd><p>Plots a heatmap of the SOM Nodes. The brighter, the further away they are from their neighbors</p>
<p>som_model:  
The trained SOM</p>
<p>cmap: str
The matplotlib based color scale to use for the plots</p>
<p>figsize: tuple
The size of the figure</p>
<p>save_figs: bool
Whether to save the figure or not</p>
<p>fig_save_path: str
Where to save the figure. Note that it creates a directory called Plots in the location given.</p>
<p>Plot:
The heatmap plot</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="QNPy.Clustering_with_SOM.Structure_Function">
<span class="sig-prename descclassname"><span class="pre">QNPy.Clustering_with_SOM.</span></span><span class="sig-name descname"><span class="pre">Structure_Function</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">cluster_map</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">selected_cluster</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lcs</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bins</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">save_figs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">figs_save_path</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'./'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#QNPy.Clustering_with_SOM.Structure_Function" title="Permalink to this definition"></a></dt>
<dd><p>Create the structure function for a given cluster</p>
<p>cluster_map: pd.Dataframe
A map of each of the ids to the clusters</p>
<p>selected_cluster: int
The cluster of interest</p>
<p>lcs: list of list of pd.Dataframes
The light curves (provide the input from just one filter)</p>
<p>bins:int or list
The bins to use for the structure function</p>
<p>save_figs: bool
Whether to save the figure or not</p>
<p>figs_save_path: str
Where to save the figure. Note that it is saved under a directory called Plots in that directory.</p>
<p>S+ and S- Plot: 
A plot of the S+ and S- functions for the cluster</p>
<p>Difference Plot:
The evolution of the normalized S+ - S- throughout the observation time of the cluster</p>
<p>S Plot:
The evolution of the (regular) structure function through the observation time of the cluster</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="QNPy.Clustering_with_SOM.create_dir_save_plot">
<span class="sig-prename descclassname"><span class="pre">QNPy.Clustering_with_SOM.</span></span><span class="sig-name descname"><span class="pre">create_dir_save_plot</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">path</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">plot_name</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#QNPy.Clustering_with_SOM.create_dir_save_plot" title="Permalink to this definition"></a></dt>
<dd><p>If there is no folder named plots in the path, it creates one and saves an figure</p>
<p>path: str  
The path to create the Plots folder in</p>
<p>plot_name: 
The name to save the plot under</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="QNPy.Clustering_with_SOM.findInternalNode">
<span class="sig-prename descclassname"><span class="pre">QNPy.Clustering_with_SOM.</span></span><span class="sig-name descname"><span class="pre">findInternalNode</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">umat</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#QNPy.Clustering_with_SOM.findInternalNode" title="Permalink to this definition"></a></dt>
<dd><p>Finds the minimum node in the unified matrix when given the x and y coordinate, taking into account if the current node is min</p>
<p>x: int  
The x position of the given input node</p>
<p>y: int  
The y position of the given input node</p>
<p>umat: np.ndarry
The unified distance matrix of the nodes of the SOM</p>
<p>minx, miny:
The minumum x node and minimum y node</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="QNPy.Clustering_with_SOM.findMin">
<span class="sig-prename descclassname"><span class="pre">QNPy.Clustering_with_SOM.</span></span><span class="sig-name descname"><span class="pre">findMin</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">umat</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#QNPy.Clustering_with_SOM.findMin" title="Permalink to this definition"></a></dt>
<dd><p>Finds the minimum node in the unified matrix when given the x and y coordinate</p>
<p>x: int  
The x position of the given input node</p>
<p>y: int  
The y position of the given input node</p>
<p>umat: np.ndarry
The unified distance matrix of the nodes of the SOM</p>
<p>minx, miny:
The minumum x node and minimum y node</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="QNPy.Clustering_with_SOM.find_cluster_and_quantization_errors">
<span class="sig-prename descclassname"><span class="pre">QNPy.Clustering_with_SOM.</span></span><span class="sig-name descname"><span class="pre">find_cluster_and_quantization_errors</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">som</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">data</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">masks</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#QNPy.Clustering_with_SOM.find_cluster_and_quantization_errors" title="Permalink to this definition"></a></dt>
<dd><p>Finding the clusters and the quantization errors from the trained 2D SOM</p>
<p>som: 
The trained SOM</p>
<p>data: 
The processed light curves from the trained SOM</p>
<p>masks: 
The masks used from the trained SOM</p>
<p>min_clusters:
The clusters for each of the data points</p>
<p>quantization_error:
The quantization error of each of the data points</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="QNPy.Clustering_with_SOM.get_best_grid">
<span class="sig-prename descclassname"><span class="pre">QNPy.Clustering_with_SOM.</span></span><span class="sig-name descname"><span class="pre">get_best_grid</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">number_of_objects</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#QNPy.Clustering_with_SOM.get_best_grid" title="Permalink to this definition"></a></dt>
<dd><p>Creates a grid that is optimal for the number of objects</p>
<p>number_of_objects: int  
The number of objects to make the grid for</p>
<p>rows:
The number of rows for the grid</p>
<p>cols:
The number of cols for the grid</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="QNPy.Clustering_with_SOM.get_fvars">
<span class="sig-prename descclassname"><span class="pre">QNPy.Clustering_with_SOM.</span></span><span class="sig-name descname"><span class="pre">get_fvars</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">lcs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#QNPy.Clustering_with_SOM.get_fvars" title="Permalink to this definition"></a></dt>
<dd><p>Calculates the variability function of the light curves</p>
<p>lcs:  List of pd.Dataframes
The light curves of interest</p>
<p>fvars:
The list of variability functions</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="QNPy.Clustering_with_SOM.get_luminosities_and_masses">
<span class="sig-prename descclassname"><span class="pre">QNPy.Clustering_with_SOM.</span></span><span class="sig-name descname"><span class="pre">get_luminosities_and_masses</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">lcs</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">redshifts_map</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">H0</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">67.4</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Om0</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.315</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#QNPy.Clustering_with_SOM.get_luminosities_and_masses" title="Permalink to this definition"></a></dt>
<dd><p>Randomly samples the luminosity and masses of the quasar black holes assuming a given Hubble Constant, Omega_0, and redshift</p>
<p>lcs:  List of pd.Dataframes
The light curves of interest</p>
<p>redshifts_map: pd.DataFrame
The map from the ids to their redshifts</p>
<p>H0: float
The hubble constant at z=0</p>
<p>Om0: float
Omega matter: density of non-relativistic matter in units of the critical density at z=0.</p>
<p>Log_lum:
The logarithm of the luminosities</p>
<p>Log_Mass:
The logarithm of the masses</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="QNPy.Clustering_with_SOM.get_redshifts">
<span class="sig-prename descclassname"><span class="pre">QNPy.Clustering_with_SOM.</span></span><span class="sig-name descname"><span class="pre">get_redshifts</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">redshifts_map</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#QNPy.Clustering_with_SOM.get_redshifts" title="Permalink to this definition"></a></dt>
<dd><p>Gets all the redshifts from a redshifts map</p>
<p>redshifts_map:  pd.Dataframe
The mapping of ids to redshifts</p>
<p>redshifts:
The list of redshifts</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="QNPy.Clustering_with_SOM.masked_euclidean_distance">
<span class="sig-prename descclassname"><span class="pre">QNPy.Clustering_with_SOM.</span></span><span class="sig-name descname"><span class="pre">masked_euclidean_distance</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">data2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mask</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#QNPy.Clustering_with_SOM.masked_euclidean_distance" title="Permalink to this definition"></a></dt>
<dd><p>Calculates the masked euclidean distance between two arrays using a common mask</p>
<p>data1: np.ndarray
The first array</p>
<p>data2: np.ndarray
The second array</p>
<p>mask: np.ma.mask
The mask used to get the distance</p>
<p>masked_distance:
The masked distance measure</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="QNPy.Clustering_with_SOM.matplotlib_cmap_to_plotly">
<span class="sig-prename descclassname"><span class="pre">QNPy.Clustering_with_SOM.</span></span><span class="sig-name descname"><span class="pre">matplotlib_cmap_to_plotly</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">cmap</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">entries</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#QNPy.Clustering_with_SOM.matplotlib_cmap_to_plotly" title="Permalink to this definition"></a></dt>
<dd><p>Creates a colorscale used to create an interactive plot</p>
<p>cmap:  
The colormap</p>
<p>entries: 
The colormap entries</p>
<p>colorscale:
The colorscale for the interactive plot</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="QNPy.Clustering_with_SOM.multi_band_clustering">
<span class="sig-prename descclassname"><span class="pre">QNPy.Clustering_with_SOM.</span></span><span class="sig-name descname"><span class="pre">multi_band_clustering</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">light_curves</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ids</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">filter_names</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'ugriz'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">som_x</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">som_y</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sigma</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">learning_rate</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.5</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">num_iterations</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">batch_size</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">5</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">early_stopping_no</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#QNPy.Clustering_with_SOM.multi_band_clustering" title="Permalink to this definition"></a></dt>
<dd><p>Multiband light curve clustering</p>
<p>light_curves: 
The light curves to be used</p>
<p>ids: list,array
The ids of the quasars</p>
<p>filter_names: list or str(if the filters are one letter)
The filters that are used</p>
<p>som_x: int
The x size of the SOM. If None is given, make sure the som_y is None as well. Then, it chooses the recommended SOM 
size of sqrt(sqrt(length))</p>
<p>som_y: int
The y size of the SOM. If None is given, make sure the som_x is None as well. Then, it chooses the recommended SOM 
size of sqrt(sqrt(length))</p>
<p>sigma: float
The effect each node has on its neighboring nodes</p>
<p>learning_rate: float
How much the SOM learns from the new data that it sees</p>
<p>num_iterations: int
The number of iterations that the som is trained on each batch</p>
<p>batch_size: int
The size of each batch</p>
<p>early_stopping_no: int or None
The number of batches to process before stopping. Use None if you should train on all</p>
<p>som:
The trained SOM</p>
<p>processed_light_curve:
The flat light curves used for the SOM</p>
<p>processed_mask:
The mask used for the SOM</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="QNPy.Clustering_with_SOM.multi_band_processing">
<span class="sig-prename descclassname"><span class="pre">QNPy.Clustering_with_SOM.</span></span><span class="sig-name descname"><span class="pre">multi_band_processing</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">light_curves</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ids</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">filter_names</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'ugriz'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">return_wide</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#QNPy.Clustering_with_SOM.multi_band_processing" title="Permalink to this definition"></a></dt>
<dd><p>Processes the light curves into a wide table</p>
<p>light_curves: 
The light curves to be used</p>
<p>ids: list,array
The ids of the quasars</p>
<p>filter_names: list or str(if the filters are one letter)
The filters that are used</p>
<p>return_wide: bool
Whether to return the wide table or a flat table</p>
<p>light_curves_wide:
The pivot table of the light curves with time steps</p>
<p>light_curves_wide.isna():
The mask used with the wide light curves</p>
<p>OR</p>
<p>light_curves_flat:
The flattened pivot table of the light curves</p>
<p>mask_flat:
The mask used</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="QNPy.Clustering_with_SOM.outliers_detection">
<span class="sig-prename descclassname"><span class="pre">QNPy.Clustering_with_SOM.</span></span><span class="sig-name descname"><span class="pre">outliers_detection</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">clusters_df</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">som</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">scaled_curves</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ids</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">outlier_percentage</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.2</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#QNPy.Clustering_with_SOM.outliers_detection" title="Permalink to this definition"></a></dt>
<dd><p>Gives the percentage of the clusters that have high quanitization errors (defined by percentile) for each cluster</p>
<p>clusters_df:
A map of each of the ids to the clusters</p>
<p>som:  
The trained SOM</p>
<p>scaled_curves: np.ndarray
The scaled curves used to train the SOM</p>
<p>ids: list
The ids of the curves</p>
<p>outlier_percentage: float
This top percentile that defines an outlier</p>
<p>Plots:
Distribution of Outliers per cluster and distribution of quantization error</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="QNPy.Clustering_with_SOM.plotStarburstMap">
<span class="sig-prename descclassname"><span class="pre">QNPy.Clustering_with_SOM.</span></span><span class="sig-name descname"><span class="pre">plotStarburstMap</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">som</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#QNPy.Clustering_with_SOM.plotStarburstMap" title="Permalink to this definition"></a></dt>
<dd><p>Interactive plot of the distance map and gradients of the SOM</p>
<p>som:  
The trained SOM</p>
<p>Plot of the distance map and gradients</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="QNPy.Clustering_with_SOM.plot_training">
<span class="sig-prename descclassname"><span class="pre">QNPy.Clustering_with_SOM.</span></span><span class="sig-name descname"><span class="pre">plot_training</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">training_metric_results</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">metric</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">plotting_frequency</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">indices_to_plot</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">figsize</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">(10,</span> <span class="pre">10)</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">save_figs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fig_save_path</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'./'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#QNPy.Clustering_with_SOM.plot_training" title="Permalink to this definition"></a></dt>
<dd><p>Plots the metric given (quantization error or topographic error)</p>
<p>training_metric_results: list 
The result obtained from the SOM training</p>
<p>metric: str
Name of the metric</p>
<p>plotting_frequency: int
How much was the plotting frequency set during the SOM training</p>
<p>indices_to_plot: list
The indices to plot obtained from the SOM training</p>
<p>figsize: tuple
The size of the figure</p>
<p>save_figs: bool
Whether to save the figure or not</p>
<p>fig_save_path:str
Where to save the figure. Note that it creates a directory called Plots in the location given.</p>
<p>Plot:
The plot of the metric</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="QNPy.Clustering_with_SOM.save_chosen_cluster">
<span class="sig-prename descclassname"><span class="pre">QNPy.Clustering_with_SOM.</span></span><span class="sig-name descname"><span class="pre">save_chosen_cluster</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">chosen_cluster</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cluster_map</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">one_filter</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">filters</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'a'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">overwrite</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">save_path</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'./'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">source_path</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'./Light_Curves'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#QNPy.Clustering_with_SOM.save_chosen_cluster" title="Permalink to this definition"></a></dt>
<dd><p>Saves the chosen cluster into a folder</p>
<p>chosen_cluster: int
The cluster to save</p>
<p>cluster_map: pd.Dataframe
A map of each of the ids to the clusters</p>
<p>one_filter: bool
Whether to save just one filter or all the filters</p>
<p>filters: str
The filters to save</p>
<p>overwrite: bool
Whether to overwrite the current folder</p>
<p>save_path: str
The path to save to. This creates a folder for the cluster in that directory</p>
<p>source_path: str
The path that the light curves are saved in. If multifilter, provide the entire larger folder.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="QNPy.Clustering_with_SOM.scale_curves">
<span class="sig-prename descclassname"><span class="pre">QNPy.Clustering_with_SOM.</span></span><span class="sig-name descname"><span class="pre">scale_curves</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">light_curves</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">what_scaler</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'default'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">scale_times</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#QNPy.Clustering_with_SOM.scale_curves" title="Permalink to this definition"></a></dt>
<dd><p>Scaling the curves (from a single filter) from the choice of minmax, standard and robust. By default, it scales to a range of [-2,2]
Parameters
———-
light_curves: list of dataframes 
The light curves stored in a list.</p>
<p>what_scaler: string
The type of scaler to use. There are default (see above), standard scaler, min-max scaler and robust scalers available</p>
<p>scale_times: bool
Whether to scale the time axis as well (These are always scaled to the default scaler)</p>
<p>scaled_curves: np.ndarray 
The scaled light curves</p>
<p>scaled_times:np.ndarray
The scaled time steps. It is an empty list if the keyword scale_times is False</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="QNPy.Clustering_with_SOM.scale_to_range">
<span class="sig-prename descclassname"><span class="pre">QNPy.Clustering_with_SOM.</span></span><span class="sig-name descname"><span class="pre">scale_to_range</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">series</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">min_val</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">-</span> <span class="pre">2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_val</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">2</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#QNPy.Clustering_with_SOM.scale_to_range" title="Permalink to this definition"></a></dt>
<dd><p>Scales a series to a range</p>
<p>series: pd.Series 
The series to scale</p>
<p>min_val: int
The minimum value to scale to</p>
<p>max_val: int
The maximum value to scale to</p>
<p>scaled_series:
The scaled series between the max and min values</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="QNPy.Clustering_with_SOM.tolerant_mean">
<span class="sig-prename descclassname"><span class="pre">QNPy.Clustering_with_SOM.</span></span><span class="sig-name descname"><span class="pre">tolerant_mean</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">arrs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#QNPy.Clustering_with_SOM.tolerant_mean" title="Permalink to this definition"></a></dt>
<dd><p>Calculates the mean of arrays without them having to be the same length</p>
<p>arrs:  
The arrays to calculate the mean for</p>
<p>mean:
The tolerant mean of the arrays</p>
<p>std:
The tolerant std of the arrays</p>
</dd></dl>

</section>
<section id="module-QNPy.PREDICTION">
<span id="qnpy-prediction-module"></span><h2>QNPy.PREDICTION module<a class="headerlink" href="#module-QNPy.PREDICTION" title="Permalink to this heading"></a></h2>
<dl class="py function">
<dt class="sig sig-object py" id="QNPy.PREDICTION.create_prediction_folders">
<span class="sig-prename descclassname"><span class="pre">QNPy.PREDICTION.</span></span><span class="sig-name descname"><span class="pre">create_prediction_folders</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">base_dir</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'./output/predictions'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#QNPy.PREDICTION.create_prediction_folders" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="QNPy.PREDICTION.get_criteria">
<span class="sig-prename descclassname"><span class="pre">QNPy.PREDICTION.</span></span><span class="sig-name descname"><span class="pre">get_criteria</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#QNPy.PREDICTION.get_criteria" title="Permalink to this definition"></a></dt>
<dd><p>– Gives the criterion and mse_metric</p>
<p>How to use: criterion, mseMetric=get_criteria()</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="QNPy.PREDICTION.load_test_data">
<span class="sig-prename descclassname"><span class="pre">QNPy.PREDICTION.</span></span><span class="sig-name descname"><span class="pre">load_test_data</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data_path</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#QNPy.PREDICTION.load_test_data" title="Permalink to this definition"></a></dt>
<dd><p>– takes data_path as an argument, creates a LighCurvesDataset and returns a PyTorch DataLoader for the test set. The DataLoader is used to load and preprocess the test data in batches</p>
<p>Args:
:param str data_path: path to Test data</p>
<p>How to use: testLoader=load_test_data(DATA_PATH_TEST)</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="QNPy.PREDICTION.load_train_data">
<span class="sig-prename descclassname"><span class="pre">QNPy.PREDICTION.</span></span><span class="sig-name descname"><span class="pre">load_train_data</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data_path</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#QNPy.PREDICTION.load_train_data" title="Permalink to this definition"></a></dt>
<dd><p>– takes data_path as an argument, creates a LighCurvesDataset and returns a PyTorch DataLoader for the test set. The DataLoader is used to load and preprocess the test data in batches</p>
<p>Args:
:param str data_path: path to train data</p>
<p>How to use: trainLoader=load_train_data(DATA_PATH_TRAIN)</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="QNPy.PREDICTION.load_trained_model">
<span class="sig-prename descclassname"><span class="pre">QNPy.PREDICTION.</span></span><span class="sig-name descname"><span class="pre">load_trained_model</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">MODEL_PATH</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">device</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#QNPy.PREDICTION.load_trained_model" title="Permalink to this definition"></a></dt>
<dd><p>–Uploading trained model</p>
<p>agrs:
:param str MODEL_PATH = path to model directorium
:param device = torch device CPU or CUDA</p>
<p>How to use: model=load_trained_model(MODEL_PATH, device)</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="QNPy.PREDICTION.load_val_data">
<span class="sig-prename descclassname"><span class="pre">QNPy.PREDICTION.</span></span><span class="sig-name descname"><span class="pre">load_val_data</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data_path</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#QNPy.PREDICTION.load_val_data" title="Permalink to this definition"></a></dt>
<dd><p>– takes data_path as an argument, creates a LighCurvesDataset and returns a PyTorch DataLoader for the test set. The DataLoader is used to load and preprocess the test data in batches</p>
<p>Args:
:param str data_path: path to VAL data</p>
<p>How to use: valLoader=load_val_data(DATA_PATH_VAL)</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="QNPy.PREDICTION.plot_function">
<span class="sig-prename descclassname"><span class="pre">QNPy.PREDICTION.</span></span><span class="sig-name descname"><span class="pre">plot_function</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">target_x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">target_y</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">context_x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">context_y</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pred_y</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">var</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">target_test_x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lcName</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">save</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">flagval</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">isTrainData</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">notTrainData</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#QNPy.PREDICTION.plot_function" title="Permalink to this definition"></a></dt>
<dd><p>– Defines the plots of the light curve data and predicted mean and variance, and it should be imported separately</p>
<p>Args:
:param context_x: Array of shape BATCH_SIZE x NUM_CONTEXT that contains the x values of the context points.
:param context_y: Array of shape BATCH_SIZE x NUM_CONTEXT that contains the y values of the context points.
:param target_x: Array of shape BATCH_SIZE x NUM_TARGET that contains the x values of the target points.
:param target_y: Array of shape BATCH_SIZE x NUM_TARGET that contains the ground truth y values of the target points.
:param target_test_x: Array of shape BATCH_SIZE x 400 that contains uniformly spread points across in [-2, 2] range.
:param pred_y: Array of shape BATCH_SIZE x 400 that contains predictions across [-2, 2] range.
:param var: An array of shape BATCH_SIZE x 400  that contains the variance of predictions at target_test_x points.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="QNPy.PREDICTION.plot_light_curves_from_test_set">
<span class="sig-prename descclassname"><span class="pre">QNPy.PREDICTION.</span></span><span class="sig-name descname"><span class="pre">plot_light_curves_from_test_set</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">model</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">testLoader</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">criterion</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mseMetric</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">plot_function</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">device</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#QNPy.PREDICTION.plot_light_curves_from_test_set" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="QNPy.PREDICTION.plot_light_curves_from_train_set">
<span class="sig-prename descclassname"><span class="pre">QNPy.PREDICTION.</span></span><span class="sig-name descname"><span class="pre">plot_light_curves_from_train_set</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">trainLoader</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">model</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">criterion</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mseMetric</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">plot_function</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">device</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#QNPy.PREDICTION.plot_light_curves_from_train_set" title="Permalink to this definition"></a></dt>
<dd><p>– Ploting the transformed light curves from train set</p>
<p>Args:
:param model: Deterministic model
:param trainLoader: Uploaded trained data
:param criterion: criterion
:param mseMetric: Mse Metric
:param plot_function: plot function defined above
:param device: torch device CPU or CUDA</p>
<p>How to use: trainMetrics = plot_light_curves_from_train_set(model, trainLoader, criterion, mseMetric, plot_function, device)</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="QNPy.PREDICTION.plot_light_curves_from_val_set">
<span class="sig-prename descclassname"><span class="pre">QNPy.PREDICTION.</span></span><span class="sig-name descname"><span class="pre">plot_light_curves_from_val_set</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">model</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">valLoader</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">criterion</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mseMetric</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">plot_function</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">device</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#QNPy.PREDICTION.plot_light_curves_from_val_set" title="Permalink to this definition"></a></dt>
<dd><p>– Ploting the transformed light curves from validation set</p>
<p>Args:
:param model: Deterministic model
:param valLoader: Uploaded val data
:param criterion: criterion
:param mseMetric: Mse Metric
:param plot_function: plot function defined above
:param device: torch device CPU or CUDA</p>
<p>How to use: valMetrics = plot_light_curves_from_val_set(model, valLoader, criterion, mseMetric, plot_function, device)</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="QNPy.PREDICTION.prepare_output_dir">
<span class="sig-prename descclassname"><span class="pre">QNPy.PREDICTION.</span></span><span class="sig-name descname"><span class="pre">prepare_output_dir</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">OUTPUT_PATH</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#QNPy.PREDICTION.prepare_output_dir" title="Permalink to this definition"></a></dt>
<dd><p>– the function prepare_output_dir takes the <cite>OUTPUT_PATH</cite> as an argument and removes all files in the output directory using os.walk method.</p>
<p>Args:
:param str OUTPUT_PATH: path to output folder</p>
<p>How to use: prepare_output_dir(OUTPUT_PATH)</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="QNPy.PREDICTION.remove_padded_values_and_filter">
<span class="sig-prename descclassname"><span class="pre">QNPy.PREDICTION.</span></span><span class="sig-name descname"><span class="pre">remove_padded_values_and_filter</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">folder_path</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#QNPy.PREDICTION.remove_padded_values_and_filter" title="Permalink to this definition"></a></dt>
<dd><p>– Preparing data for plotting. It’ll remove the padded values from lc and it’ll delete artifitially added lc with plus and minus errors. If your lc are not padded it’ll only delete additional curves</p>
<p>Args:
:param str folder_path: Path to folder where the curves are. In this case it’ll be ‘./dataset/test’ or ‘./dataset/train’ or ‘./dataset/val’</p>
<p>How to use: 
if __name__ == “__main__”:
folder_path = “./dataset/test”  # Change this to your dataset folder</p>
<p>remove_padded_values_and_filter(folder_path)</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="QNPy.PREDICTION.save_test_metrics">
<span class="sig-prename descclassname"><span class="pre">QNPy.PREDICTION.</span></span><span class="sig-name descname"><span class="pre">save_test_metrics</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">OUTPUT_PATH</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">testMetrics</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#QNPy.PREDICTION.save_test_metrics" title="Permalink to this definition"></a></dt>
<dd><p>– saving the test metrics as json file</p>
<p>Args:
:param str OUTPUT_PATH: path to output folder
:param testMetrics: returned data from ploting function</p>
<p>How to use: save_test_metrics(OUTPUT_PATH, testMetrics)</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="QNPy.PREDICTION.save_train_metrics">
<span class="sig-prename descclassname"><span class="pre">QNPy.PREDICTION.</span></span><span class="sig-name descname"><span class="pre">save_train_metrics</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">OUTPUT_PATH</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">trainMetrics</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#QNPy.PREDICTION.save_train_metrics" title="Permalink to this definition"></a></dt>
<dd><p>– saving the train metrics as json file</p>
<p>Args:
:param str OUTPUT_PATH: path to output folder
:param trainMetrics: returned data from ploting function</p>
<p>How to use: save_train_metrics(OUTPUT_PATH, trainMetrics)</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="QNPy.PREDICTION.save_val_metrics">
<span class="sig-prename descclassname"><span class="pre">QNPy.PREDICTION.</span></span><span class="sig-name descname"><span class="pre">save_val_metrics</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">OUTPUT_PATH</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">valMetrics</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#QNPy.PREDICTION.save_val_metrics" title="Permalink to this definition"></a></dt>
<dd><p>– saving the validation metrics as json file</p>
<p>Args:
:param str OUTPUT_PATH: path to output folder
:param valMetrics: returned data from ploting function</p>
<p>How to use: save_val_metrics(OUTPUT_PATH, valMetrics)</p>
</dd></dl>

</section>
<section id="module-QNPy.PREDICTION_Original_mjd">
<span id="qnpy-prediction-original-mjd-module"></span><h2>QNPy.PREDICTION_Original_mjd module<a class="headerlink" href="#module-QNPy.PREDICTION_Original_mjd" title="Permalink to this heading"></a></h2>
<dl class="py function">
<dt class="sig sig-object py" id="QNPy.PREDICTION_Original_mjd.back_x">
<span class="sig-prename descclassname"><span class="pre">QNPy.PREDICTION_Original_mjd.</span></span><span class="sig-name descname"><span class="pre">back_x</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Ax</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Bx</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#QNPy.PREDICTION_Original_mjd.back_x" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="QNPy.PREDICTION_Original_mjd.back_y">
<span class="sig-prename descclassname"><span class="pre">QNPy.PREDICTION_Original_mjd.</span></span><span class="sig-name descname"><span class="pre">back_y</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">y</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Ay</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">By</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#QNPy.PREDICTION_Original_mjd.back_y" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="QNPy.PREDICTION_Original_mjd.create_prediction_folders">
<span class="sig-prename descclassname"><span class="pre">QNPy.PREDICTION_Original_mjd.</span></span><span class="sig-name descname"><span class="pre">create_prediction_folders</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">base_dir</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'./output/predictions'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#QNPy.PREDICTION_Original_mjd.create_prediction_folders" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="QNPy.PREDICTION_Original_mjd.find_LC_transform">
<span class="sig-prename descclassname"><span class="pre">QNPy.PREDICTION_Original_mjd.</span></span><span class="sig-name descname"><span class="pre">find_LC_transform</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">lists</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">search</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#QNPy.PREDICTION_Original_mjd.find_LC_transform" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="QNPy.PREDICTION_Original_mjd.get_criteria">
<span class="sig-prename descclassname"><span class="pre">QNPy.PREDICTION_Original_mjd.</span></span><span class="sig-name descname"><span class="pre">get_criteria</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#QNPy.PREDICTION_Original_mjd.get_criteria" title="Permalink to this definition"></a></dt>
<dd><p>– Gives the criterion and mse_metric</p>
<p>How to use: criterion, mseMetric=get_criteria()</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="QNPy.PREDICTION_Original_mjd.load_test_data">
<span class="sig-prename descclassname"><span class="pre">QNPy.PREDICTION_Original_mjd.</span></span><span class="sig-name descname"><span class="pre">load_test_data</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">DATA_PATH_TEST</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#QNPy.PREDICTION_Original_mjd.load_test_data" title="Permalink to this definition"></a></dt>
<dd><p>– takes data_path as an argument, creates a LighCurvesDataset and returns a PyTorch DataLoader for the test set. The DataLoader is used to load and preprocess the test data in batches</p>
<p>Args:
:param str data_path: path to Test data</p>
<p>How to use: testLoader=load_test_data(DATA_PATH_TEST)</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="QNPy.PREDICTION_Original_mjd.load_train_data">
<span class="sig-prename descclassname"><span class="pre">QNPy.PREDICTION_Original_mjd.</span></span><span class="sig-name descname"><span class="pre">load_train_data</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data_path</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#QNPy.PREDICTION_Original_mjd.load_train_data" title="Permalink to this definition"></a></dt>
<dd><p>– takes data_path as an argument, creates a LighCurvesDataset and returns a PyTorch DataLoader for the test set. The DataLoader is used to load and preprocess the test data in batches</p>
<p>Args:
:param str data_path: path to train data</p>
<p>How to use: trainLoader=load_train_data(DATA_PATH_TRAIN)</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="QNPy.PREDICTION_Original_mjd.load_trained_model">
<span class="sig-prename descclassname"><span class="pre">QNPy.PREDICTION_Original_mjd.</span></span><span class="sig-name descname"><span class="pre">load_trained_model</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">MODEL_PATH</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">device</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#QNPy.PREDICTION_Original_mjd.load_trained_model" title="Permalink to this definition"></a></dt>
<dd><p>–Uploading trained model</p>
<p>agrs:
:param str MODEL_PATH = path to model directorium
:param str device = torch device CPU or CUDA</p>
<p>How to use: model=load_trained_model(MODEL_PATH, device)</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="QNPy.PREDICTION_Original_mjd.load_trcoeff">
<span class="sig-prename descclassname"><span class="pre">QNPy.PREDICTION_Original_mjd.</span></span><span class="sig-name descname"><span class="pre">load_trcoeff</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#QNPy.PREDICTION_Original_mjd.load_trcoeff" title="Permalink to this definition"></a></dt>
<dd><p>– loading the original coefficients from pickle file</p>
<p>How to use: tr=load_trcoeff()</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="QNPy.PREDICTION_Original_mjd.load_val_data">
<span class="sig-prename descclassname"><span class="pre">QNPy.PREDICTION_Original_mjd.</span></span><span class="sig-name descname"><span class="pre">load_val_data</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data_path</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#QNPy.PREDICTION_Original_mjd.load_val_data" title="Permalink to this definition"></a></dt>
<dd><p>– takes data_path as an argument, creates a LighCurvesDataset and returns a PyTorch DataLoader for the test set. The DataLoader is used to load and preprocess the test data in batches</p>
<p>Args:
:param str data_path: path to VAL data</p>
<p>How to use: valLoader=load_val_data(DATA_PATH_VAL)</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="QNPy.PREDICTION_Original_mjd.plot_function2">
<span class="sig-prename descclassname"><span class="pre">QNPy.PREDICTION_Original_mjd.</span></span><span class="sig-name descname"><span class="pre">plot_function2</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">tr</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">target_x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">target_y</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">context_x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">context_y</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">yerr1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pred_y</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">var</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">target_test_x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lcName</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">save</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">isTrainData</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">flagval</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">notTrainData</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#QNPy.PREDICTION_Original_mjd.plot_function2" title="Permalink to this definition"></a></dt>
<dd><p>Plots the light curve data and predicted mean and variance.</p>
<p>Args: 
context_x: Array of shape BATCH_SIZE x NUM_CONTEXT that contains the x values of the context points.
context_y: Array of shape BATCH_SIZE x NUM_CONTEXT that contains the y values of the context points.
target_x: Array of shape BATCH_SIZE x NUM_TARGET that contains the x values of the target points.
target_y: Array of shape BATCH_SIZE x NUM_TARGET that contains the ground truth y values of the target points.
target_test_x: Array of shape BATCH_SIZE x 400 that contains uniformly spread points across in [-2, 2] range.
yerr1: Array of shape BATCH_SIZE x NUM_measurement_error that contains the measurement errors.
pred_y: Array of shape BATCH_SIZE x 400 that contains predictions across [-2, 2] range.
var: An array of shape BATCH_SIZE x 400  that contains the variance of predictions at target_test_x points.
tr: array of data in pickle format needed to backtransform data from [-2,2] x [-2,2] to MJD x Mag</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="QNPy.PREDICTION_Original_mjd.plot_test_data">
<span class="sig-prename descclassname"><span class="pre">QNPy.PREDICTION_Original_mjd.</span></span><span class="sig-name descname"><span class="pre">plot_test_data</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">model</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">testLoader</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">criterion</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mseMetric</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">plot_function2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">device</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tr</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#QNPy.PREDICTION_Original_mjd.plot_test_data" title="Permalink to this definition"></a></dt>
<dd><p>– Ploting the light curves from test set in original mjd range</p>
<p>Args:
:param model: Deterministic model
:param testLoader: Uploaded test data
:param criterion: criterion
:param mseMetric: Mse Metric
:param plot_function: plot function defined above
:param device: torch device CPU or CUDA
:param tr: trcoeff from pickle file</p>
<p>How  to use: testMetrics=plot_test_data(model, testLoader, criterion, mseMetric, plot_function2, device, tr)</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="QNPy.PREDICTION_Original_mjd.plot_train_light_curves">
<span class="sig-prename descclassname"><span class="pre">QNPy.PREDICTION_Original_mjd.</span></span><span class="sig-name descname"><span class="pre">plot_train_light_curves</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">trainLoader</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">model</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">criterion</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mseMetric</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">plot_function</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">device</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tr</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#QNPy.PREDICTION_Original_mjd.plot_train_light_curves" title="Permalink to this definition"></a></dt>
<dd><p>–Plots light curves from test set in original range MJD x Mag</p>
<p>Args:
model (torch.nn.Module): Trained probabilistic model
criterion (torch.nn.Module): Loss function
mseMetric (function): Mean squared error metric
trainLoader (torch.utils.data.DataLoader): Dataloader for training set
device (str): Device for PyTorch model
tr (pd.DataFrame): Transforming coefficients DataFrame for LCs</p>
<dl class="simple">
<dt>Returns:</dt><dd><p>trainMetrics (dict): Log probability and MSE metrics for train set</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="QNPy.PREDICTION_Original_mjd.plot_val_curves">
<span class="sig-prename descclassname"><span class="pre">QNPy.PREDICTION_Original_mjd.</span></span><span class="sig-name descname"><span class="pre">plot_val_curves</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">model</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">valLoader</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">criterion</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mseMetric</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">plot_function</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">device</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tr</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#QNPy.PREDICTION_Original_mjd.plot_val_curves" title="Permalink to this definition"></a></dt>
<dd><p>– Ploting the light curves from val set in original mjd range</p>
<p>Args:
:param model: Deterministic model
:param valLoader: Uploaded val data
:param criterion: criterion
:param mseMetric: Mse Metric
:param plot_function: plot function defined above
:param device: torch device CPU or CUDA
:param tr: trcoeff from pikle file</p>
<p>How to use: valMetrics=plot_val_curves(model, valLoader, criterion, mseMetric, plot_function2, device,tr)</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="QNPy.PREDICTION_Original_mjd.prepare_output_dir">
<span class="sig-prename descclassname"><span class="pre">QNPy.PREDICTION_Original_mjd.</span></span><span class="sig-name descname"><span class="pre">prepare_output_dir</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">OUTPUT_PATH</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#QNPy.PREDICTION_Original_mjd.prepare_output_dir" title="Permalink to this definition"></a></dt>
<dd><p>– the function prepare_output_dir takes the OUTPUT_PATH       as an argument and removes all files in the output    directory using os.walk method.</p>
<p>Args:
:param str OUTPUT_PATH: path to output folder</p>
<p>How to use: prepare_output_dir(OUTPUT_PATH)</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="QNPy.PREDICTION_Original_mjd.remove_padded_values_and_filter">
<span class="sig-prename descclassname"><span class="pre">QNPy.PREDICTION_Original_mjd.</span></span><span class="sig-name descname"><span class="pre">remove_padded_values_and_filter</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">folder_path</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#QNPy.PREDICTION_Original_mjd.remove_padded_values_and_filter" title="Permalink to this definition"></a></dt>
<dd><p>– Preparing data for plotting. It’ll remove the padded values from lc and it’ll delete artifitially added lc with plus and minus errors. If your lc are not padded it’ll only delete additional curves</p>
<p>Args:
:param str folder_path: Path to folder where the curves are. In this case it’ll be ‘./dataset/test’ or ‘./dataset/train’ or ‘./dataset/val’</p>
<p>How to use:</p>
<p>folder_path = “./dataset/test”  # Change this to your dataset folder</p>
<p>remove_padded_values_and_filter(folder_path)</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="QNPy.PREDICTION_Original_mjd.save_test_metrics">
<span class="sig-prename descclassname"><span class="pre">QNPy.PREDICTION_Original_mjd.</span></span><span class="sig-name descname"><span class="pre">save_test_metrics</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">OUTPUT_PATH</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">testMetrics</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#QNPy.PREDICTION_Original_mjd.save_test_metrics" title="Permalink to this definition"></a></dt>
<dd><p>– saving the test metrics as json file</p>
<p>Args:
:param str OUTPUT_PATH: path to output folder
:param testMetrics: returned data from ploting function</p>
<p>How to use: save_test_metrics(OUTPUT_PATH, testMetrics)</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="QNPy.PREDICTION_Original_mjd.save_train_metrics">
<span class="sig-prename descclassname"><span class="pre">QNPy.PREDICTION_Original_mjd.</span></span><span class="sig-name descname"><span class="pre">save_train_metrics</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">OUTPUT_PATH</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">trainMetrics</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#QNPy.PREDICTION_Original_mjd.save_train_metrics" title="Permalink to this definition"></a></dt>
<dd><p>– saving the train metrics as json file</p>
<p>Args:
:param str OUTPUT_PATH: path to output folder
:param trainMetrics: returned data from ploting function</p>
<p>How to use: save_train_metrics(OUTPUT_PATH, trainMetrics)</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="QNPy.PREDICTION_Original_mjd.save_val_metrics">
<span class="sig-prename descclassname"><span class="pre">QNPy.PREDICTION_Original_mjd.</span></span><span class="sig-name descname"><span class="pre">save_val_metrics</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">OUTPUT_PATH</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">valMetrics</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#QNPy.PREDICTION_Original_mjd.save_val_metrics" title="Permalink to this definition"></a></dt>
<dd><p>– saving the val metrics as json file</p>
<p>Args:
:param str OUTPUT_PATH: path to output folder
valMetrics: returned data from ploting function</p>
<p>How to use: save_val_metrics(OUTPUT_PATH, valMetrics)</p>
</dd></dl>

</section>
<section id="module-QNPy.PREDICTION_onePDF">
<span id="qnpy-prediction-onepdf-module"></span><h2>QNPy.PREDICTION_onePDF module<a class="headerlink" href="#module-QNPy.PREDICTION_onePDF" title="Permalink to this heading"></a></h2>
<dl class="py function">
<dt class="sig sig-object py" id="QNPy.PREDICTION_onePDF.clear_output_dir">
<span class="sig-prename descclassname"><span class="pre">QNPy.PREDICTION_onePDF.</span></span><span class="sig-name descname"><span class="pre">clear_output_dir</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">output_path</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#QNPy.PREDICTION_onePDF.clear_output_dir" title="Permalink to this definition"></a></dt>
<dd><p>Removes all files in the specified output directory.</p>
<dl class="simple">
<dt>Args:</dt><dd><p>output_path (str): The path to the output directory.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="QNPy.PREDICTION_onePDF.create_prediction_folders">
<span class="sig-prename descclassname"><span class="pre">QNPy.PREDICTION_onePDF.</span></span><span class="sig-name descname"><span class="pre">create_prediction_folders</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">base_dir</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'./output/predictions'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#QNPy.PREDICTION_onePDF.create_prediction_folders" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="QNPy.PREDICTION_onePDF.get_criteria">
<span class="sig-prename descclassname"><span class="pre">QNPy.PREDICTION_onePDF.</span></span><span class="sig-name descname"><span class="pre">get_criteria</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#QNPy.PREDICTION_onePDF.get_criteria" title="Permalink to this definition"></a></dt>
<dd><p>– Gives the criterion and mse_metric</p>
<p>How to use: criterion, mseMetric=get_criteria()</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="QNPy.PREDICTION_onePDF.instantiate_pdf_document">
<span class="sig-prename descclassname"><span class="pre">QNPy.PREDICTION_onePDF.</span></span><span class="sig-name descname"><span class="pre">instantiate_pdf_document</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">testSet</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#QNPy.PREDICTION_onePDF.instantiate_pdf_document" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="QNPy.PREDICTION_onePDF.load_model">
<span class="sig-prename descclassname"><span class="pre">QNPy.PREDICTION_onePDF.</span></span><span class="sig-name descname"><span class="pre">load_model</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">model_path</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">device</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#QNPy.PREDICTION_onePDF.load_model" title="Permalink to this definition"></a></dt>
<dd><p>Loads a trained model from disk and moves it to the specified device.</p>
<p>Args:
model_path (str): The path to the saved model.
device (str or torch.device): The device to load the model onto.</p>
<dl class="simple">
<dt>Returns:</dt><dd><p>The loaded model.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="QNPy.PREDICTION_onePDF.load_test_data">
<span class="sig-prename descclassname"><span class="pre">QNPy.PREDICTION_onePDF.</span></span><span class="sig-name descname"><span class="pre">load_test_data</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">DATA_PATH_TEST</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#QNPy.PREDICTION_onePDF.load_test_data" title="Permalink to this definition"></a></dt>
<dd><p>– takes data_path as an argument, creates a LighCurvesDataset and returns a PyTorch DataLoader for the test set. The DataLoader is used to load and preprocess the test data in batches</p>
<p>Args:
:param str data_path: path to Test data</p>
<p>How to use: testLoader=load_test_data(DATA_PATH_TEST)</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="QNPy.PREDICTION_onePDF.load_train_data">
<span class="sig-prename descclassname"><span class="pre">QNPy.PREDICTION_onePDF.</span></span><span class="sig-name descname"><span class="pre">load_train_data</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">DATA_PATH_TRAIN</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#QNPy.PREDICTION_onePDF.load_train_data" title="Permalink to this definition"></a></dt>
<dd><p>– takes data_path as an argument, creates a LighCurvesDataset and returns a PyTorch DataLoader for the test set. The DataLoader is used to load and preprocess the test data in batches</p>
<p>Args:
:param str data_path: path to train data</p>
<p>How to use: trainLoader=load_train_data(DATA_PATH_TRAIN)</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="QNPy.PREDICTION_onePDF.load_val_data">
<span class="sig-prename descclassname"><span class="pre">QNPy.PREDICTION_onePDF.</span></span><span class="sig-name descname"><span class="pre">load_val_data</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">DATA_PATH_VAL</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#QNPy.PREDICTION_onePDF.load_val_data" title="Permalink to this definition"></a></dt>
<dd><p>– takes data_path as an argument, creates a LighCurvesDataset and returns a PyTorch DataLoader for the test set. The DataLoader is used to load and preprocess the test data in batches</p>
<p>Args:
:param str data_path: path to VAL data</p>
<p>How to use: valLoader=load_val_data(DATA_PATH_VAL)</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="QNPy.PREDICTION_onePDF.plot_function">
<span class="sig-prename descclassname"><span class="pre">QNPy.PREDICTION_onePDF.</span></span><span class="sig-name descname"><span class="pre">plot_function</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">target_x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">target_y</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">context_x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">context_y</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">yerr1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pred_y</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">var</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">target_test_x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lcName</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">save</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">flagval</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">isTrainData</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">notTraindata</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#QNPy.PREDICTION_onePDF.plot_function" title="Permalink to this definition"></a></dt>
<dd><p>Plots the light curve data and predicted mean and variance.</p>
<p>Args: 
context_x: Array of shape BATCH_SIZE x NUM_CONTEXT that contains the x values of the context points.
context_y: Array of shape BATCH_SIZE x NUM_CONTEXT that contains the y values of the context points.
target_x: Array of shape BATCH_SIZE x NUM_TARGET that contains the x values of the target points.
target_y: Array of shape BATCH_SIZE x NUM_TARGET that contains the ground truth y values of the target points.
target_test_x: Array of shape BATCH_SIZE x 400 that contains uniformly spread points across in [-2, 2] range.
pred_y: Array of shape BATCH_SIZE x 400 that contains predictions across [-2, 2] range.
var: An array of shape BATCH_SIZE x 400  that contains the variance of predictions at target_test_x points.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="QNPy.PREDICTION_onePDF.plot_test_light_curves">
<span class="sig-prename descclassname"><span class="pre">QNPy.PREDICTION_onePDF.</span></span><span class="sig-name descname"><span class="pre">plot_test_light_curves</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">model</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">testLoader</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">criterion</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mseMetric</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">plot_function</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">device</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#QNPy.PREDICTION_onePDF.plot_test_light_curves" title="Permalink to this definition"></a></dt>
<dd><p>– ploting the test set in range [-2,2]</p>
<p>Args:
:param model: model
:param testLoader: Test set
:param criterion: criterion
:param mseMetric: mse Metric
:param plot_function: defined above
:param device: Torch device, CPU or CUDA</p>
<p>how to use: testMetrics=plot_test_light_curves(model, testLoader, criterion, mseMetric, plot_function, out_pdf_test, device)</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="QNPy.PREDICTION_onePDF.plot_train_light_curves">
<span class="sig-prename descclassname"><span class="pre">QNPy.PREDICTION_onePDF.</span></span><span class="sig-name descname"><span class="pre">plot_train_light_curves</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">model</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">trainLoader</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">criterion</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mseMetric</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">plot_function</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">device</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#QNPy.PREDICTION_onePDF.plot_train_light_curves" title="Permalink to this definition"></a></dt>
<dd><p>– Ploting the transformed light curves from train set</p>
<p>Args:
:param model: Deterministic model
:param trainLoader: Uploaded trained data
:param criterion: criterion
:param mseMetric: Mse Metric
:param plot_function: plot function defined above
:param device: torch device CPU or CUDA</p>
<p>How to use: trainMetrics=plot_train_light_curves(model, trainLoader, criterion, mseMetric, plot_function, device)</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="QNPy.PREDICTION_onePDF.plot_val_light_curves">
<span class="sig-prename descclassname"><span class="pre">QNPy.PREDICTION_onePDF.</span></span><span class="sig-name descname"><span class="pre">plot_val_light_curves</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">model</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">valLoader</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">criterion</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mseMetric</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">plot_function</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">device</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#QNPy.PREDICTION_onePDF.plot_val_light_curves" title="Permalink to this definition"></a></dt>
<dd><p>– Ploting the transformed light curves from val set</p>
<p>Args:
:param model: Deterministic model
:param valLoader: Uploaded val data
:param criterion: criterion
:param mseMetric: Mse Metric
:param plot_function: plot function defined above
:param device: torch device CPU or CUDA</p>
<p>How to use: valMetrics = plot_val_light_curves(model, valLoader, criterion, mseMetric, plot_function, device)</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="QNPy.PREDICTION_onePDF.remove_padded_values_and_filter">
<span class="sig-prename descclassname"><span class="pre">QNPy.PREDICTION_onePDF.</span></span><span class="sig-name descname"><span class="pre">remove_padded_values_and_filter</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">folder_path</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#QNPy.PREDICTION_onePDF.remove_padded_values_and_filter" title="Permalink to this definition"></a></dt>
<dd><p>– Preparing data for plotting. It’ll remove the padded values from lc and it’ll delete artifitially added lc with plus and minus errors. If your lc are not padded it’ll only delete additional curves</p>
<p>Args:
:param str folder_path: Path to folder where the curves are. In this case it’ll be ‘./dataset/test’ or ‘./dataset/train’ or ‘./dataset/val’</p>
<p>How to use:</p>
<p>folder_path = “./dataset/test”  # Change this to your dataset folder</p>
<p>remove_padded_values_and_filter(folder_path)</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="QNPy.PREDICTION_onePDF.save_test_metrics">
<span class="sig-prename descclassname"><span class="pre">QNPy.PREDICTION_onePDF.</span></span><span class="sig-name descname"><span class="pre">save_test_metrics</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">output_path</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">test_metrics</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#QNPy.PREDICTION_onePDF.save_test_metrics" title="Permalink to this definition"></a></dt>
<dd><p>– saving the test metrics as json file</p>
<p>Args:
:param str OUTPUT_PATH: path to output folder
:param testMetrics: returned data from ploting function</p>
<p>How to use: save_test_metrics(OUTPUT_PATH, testMetrics)</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="QNPy.PREDICTION_onePDF.save_train_metrics">
<span class="sig-prename descclassname"><span class="pre">QNPy.PREDICTION_onePDF.</span></span><span class="sig-name descname"><span class="pre">save_train_metrics</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">output_path</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">train_metrics</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#QNPy.PREDICTION_onePDF.save_train_metrics" title="Permalink to this definition"></a></dt>
<dd><p>– saving the train metrics as json file</p>
<p>Args:
:param str OUTPUT_PATH: path to output folder
:param trainMetrics: returned data from ploting function</p>
<p>How to use: save_train_metrics(OUTPUT_PATH, trainMetrics)</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="QNPy.PREDICTION_onePDF.save_val_metrics">
<span class="sig-prename descclassname"><span class="pre">QNPy.PREDICTION_onePDF.</span></span><span class="sig-name descname"><span class="pre">save_val_metrics</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">output_path</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">val_metrics</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#QNPy.PREDICTION_onePDF.save_val_metrics" title="Permalink to this definition"></a></dt>
<dd><p>– saving the val metrics as json file</p>
<p>Args:
:param str OUTPUT_PATH: path to output folder
:param valMetrics: returned data from ploting function</p>
<p>How to use: save_val_metrics(OUTPUT_PATH, valMetrics)</p>
</dd></dl>

</section>
<section id="module-QNPy.PREDICTION_onePDF_original_mjd">
<span id="qnpy-prediction-onepdf-original-mjd-module"></span><h2>QNPy.PREDICTION_onePDF_original_mjd module<a class="headerlink" href="#module-QNPy.PREDICTION_onePDF_original_mjd" title="Permalink to this heading"></a></h2>
<dl class="py function">
<dt class="sig sig-object py" id="QNPy.PREDICTION_onePDF_original_mjd.back_x">
<span class="sig-prename descclassname"><span class="pre">QNPy.PREDICTION_onePDF_original_mjd.</span></span><span class="sig-name descname"><span class="pre">back_x</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Ax</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Bx</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#QNPy.PREDICTION_onePDF_original_mjd.back_x" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="QNPy.PREDICTION_onePDF_original_mjd.back_y">
<span class="sig-prename descclassname"><span class="pre">QNPy.PREDICTION_onePDF_original_mjd.</span></span><span class="sig-name descname"><span class="pre">back_y</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">y</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Ay</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">By</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#QNPy.PREDICTION_onePDF_original_mjd.back_y" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="QNPy.PREDICTION_onePDF_original_mjd.clear_output_dir">
<span class="sig-prename descclassname"><span class="pre">QNPy.PREDICTION_onePDF_original_mjd.</span></span><span class="sig-name descname"><span class="pre">clear_output_dir</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">output_path</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#QNPy.PREDICTION_onePDF_original_mjd.clear_output_dir" title="Permalink to this definition"></a></dt>
<dd><p>Removes all files in the specified output directory.</p>
<p>Args:
output_path (str): The path to the output directory.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="QNPy.PREDICTION_onePDF_original_mjd.create_prediction_folders">
<span class="sig-prename descclassname"><span class="pre">QNPy.PREDICTION_onePDF_original_mjd.</span></span><span class="sig-name descname"><span class="pre">create_prediction_folders</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">base_dir</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'./output/predictions'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#QNPy.PREDICTION_onePDF_original_mjd.create_prediction_folders" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="QNPy.PREDICTION_onePDF_original_mjd.find_LC_transform">
<span class="sig-prename descclassname"><span class="pre">QNPy.PREDICTION_onePDF_original_mjd.</span></span><span class="sig-name descname"><span class="pre">find_LC_transform</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">lists</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">search</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#QNPy.PREDICTION_onePDF_original_mjd.find_LC_transform" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="QNPy.PREDICTION_onePDF_original_mjd.get_criteria">
<span class="sig-prename descclassname"><span class="pre">QNPy.PREDICTION_onePDF_original_mjd.</span></span><span class="sig-name descname"><span class="pre">get_criteria</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#QNPy.PREDICTION_onePDF_original_mjd.get_criteria" title="Permalink to this definition"></a></dt>
<dd><p>– Gives the criterion and mse_metric</p>
<p>How to use: criterion, mseMetric=get_criteria()</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="QNPy.PREDICTION_onePDF_original_mjd.instantiate_pdf_document">
<span class="sig-prename descclassname"><span class="pre">QNPy.PREDICTION_onePDF_original_mjd.</span></span><span class="sig-name descname"><span class="pre">instantiate_pdf_document</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">testset</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#QNPy.PREDICTION_onePDF_original_mjd.instantiate_pdf_document" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="QNPy.PREDICTION_onePDF_original_mjd.load_model">
<span class="sig-prename descclassname"><span class="pre">QNPy.PREDICTION_onePDF_original_mjd.</span></span><span class="sig-name descname"><span class="pre">load_model</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">model_path</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">device</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#QNPy.PREDICTION_onePDF_original_mjd.load_model" title="Permalink to this definition"></a></dt>
<dd><p>Loads a trained model from disk and moves it to the specified device.</p>
<p>Args:
model_path (str): The path to the saved model.
device (str or torch.device): The device to load the model onto.</p>
<dl class="simple">
<dt>Returns:</dt><dd><p>The loaded model.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="QNPy.PREDICTION_onePDF_original_mjd.load_test_data">
<span class="sig-prename descclassname"><span class="pre">QNPy.PREDICTION_onePDF_original_mjd.</span></span><span class="sig-name descname"><span class="pre">load_test_data</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">DATA_PATH_TEST</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#QNPy.PREDICTION_onePDF_original_mjd.load_test_data" title="Permalink to this definition"></a></dt>
<dd><p>– takes data_path as an argument, creates a LighCurvesDataset and returns a PyTorch DataLoader for the test set. The DataLoader is used to load and preprocess the test data in batches</p>
<p>Args:
:param str data_path: path to Test data</p>
<p>How to use: testLoader=load_test_data(DATA_PATH_TEST)</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="QNPy.PREDICTION_onePDF_original_mjd.load_train_data">
<span class="sig-prename descclassname"><span class="pre">QNPy.PREDICTION_onePDF_original_mjd.</span></span><span class="sig-name descname"><span class="pre">load_train_data</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">DATA_PATH_TRAIN</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#QNPy.PREDICTION_onePDF_original_mjd.load_train_data" title="Permalink to this definition"></a></dt>
<dd><p>– takes data_path as an argument, creates a LighCurvesDataset and returns a PyTorch DataLoader for the test set. The DataLoader is used to load and preprocess the test data in batches</p>
<p>Args:
:param str data_path: path to train data</p>
<p>How to use: trainLoader=load_train_data(DATA_PATH_TRAIN)</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="QNPy.PREDICTION_onePDF_original_mjd.load_trcoeff">
<span class="sig-prename descclassname"><span class="pre">QNPy.PREDICTION_onePDF_original_mjd.</span></span><span class="sig-name descname"><span class="pre">load_trcoeff</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#QNPy.PREDICTION_onePDF_original_mjd.load_trcoeff" title="Permalink to this definition"></a></dt>
<dd><p>– loading the original coefficients from pickle file</p>
<p>How to use: tr=load_trcoeff()</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="QNPy.PREDICTION_onePDF_original_mjd.load_val_data">
<span class="sig-prename descclassname"><span class="pre">QNPy.PREDICTION_onePDF_original_mjd.</span></span><span class="sig-name descname"><span class="pre">load_val_data</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">DATA_PATH_VAL</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#QNPy.PREDICTION_onePDF_original_mjd.load_val_data" title="Permalink to this definition"></a></dt>
<dd><p>– takes data_path as an argument, creates a LighCurvesDataset and returns a PyTorch DataLoader for the test set. The DataLoader is used to load and preprocess the test data in batches</p>
<p>Args:
:param str data_path: path to VAL data</p>
<p>How to use: valLoader=load_val_data(DATA_PATH_VAL)</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="QNPy.PREDICTION_onePDF_original_mjd.plot_function2">
<span class="sig-prename descclassname"><span class="pre">QNPy.PREDICTION_onePDF_original_mjd.</span></span><span class="sig-name descname"><span class="pre">plot_function2</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">tr</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">target_x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">target_y</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">context_x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">context_y</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">yerr1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pred_y</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">var</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">target_test_x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lcName</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">save</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">isTrainData</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">flagval</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">notTrainData</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#QNPy.PREDICTION_onePDF_original_mjd.plot_function2" title="Permalink to this definition"></a></dt>
<dd><p>Plots the light curve data and predicted mean and variance.</p>
<p>Args: 
context_x: Array of shape BATCH_SIZE x NUM_CONTEXT that contains the x values of the context points.
context_y: Array of shape BATCH_SIZE x NUM_CONTEXT that contains the y values of the context points.
target_x: Array of shape BATCH_SIZE x NUM_TARGET that contains the x values of the target points.
target_y: Array of shape BATCH_SIZE x NUM_TARGET that contains the ground truth y values of the target points.
target_test_x: Array of shape BATCH_SIZE x 400 that contains uniformly spread points across in [-2, 2] range.
yerr1: Array of shape BATCH_SIZE x NUM_measurement_error that contains the measurement errors.
pred_y: Array of shape BATCH_SIZE x 400 that contains predictions across [-2, 2] range.
var: An array of shape BATCH_SIZE x 400  that contains the variance of predictions at target_test_x points.
tr: array of data in pickle format needed to backtransform data from [-2,2] x [-2,2] to MJD x Mag</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="QNPy.PREDICTION_onePDF_original_mjd.plot_test_light_curves">
<span class="sig-prename descclassname"><span class="pre">QNPy.PREDICTION_onePDF_original_mjd.</span></span><span class="sig-name descname"><span class="pre">plot_test_light_curves</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">model</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">testLoader</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">criterion</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mseMetric</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">plot_function2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">device</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tr</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#QNPy.PREDICTION_onePDF_original_mjd.plot_test_light_curves" title="Permalink to this definition"></a></dt>
<dd><p>– ploting the test set in original range</p>
<p>Args:
:param model: model
:param testLoader: Test set
:param criterion: criterion
:param mseMetric: mse Metric
:param plot_function2: defined above
:param device: Torch device, CPU or CUDA
:param tr: trcoeff from pickle file</p>
<p>how to use: testMetrics=plot_test_light_curves(model, testLoader, criterion, mseMetric, plot_function2, device,tr)</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="QNPy.PREDICTION_onePDF_original_mjd.plot_train_light_curves">
<span class="sig-prename descclassname"><span class="pre">QNPy.PREDICTION_onePDF_original_mjd.</span></span><span class="sig-name descname"><span class="pre">plot_train_light_curves</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">model</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">trainLoader</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">criterion</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mseMetric</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">plot_function2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">device</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tr</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#QNPy.PREDICTION_onePDF_original_mjd.plot_train_light_curves" title="Permalink to this definition"></a></dt>
<dd><p>– Ploting the light curves from train set in original mjd range</p>
<p>Args:
:param model: Deterministic model
:param trainLoader: Uploaded trained data
:param criterion: criterion
:param mseMetric: Mse Metric
:param plot_function: plot function defined above
:param device: torch device CPU or CUDA
:param tr: trcoeff from pickle file</p>
<p>How to use: trainMetrics=plot_train_light_curves(model, trainLoader, criterion, mseMetric, plot_function2, device,tr)</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="QNPy.PREDICTION_onePDF_original_mjd.plot_val_light_curves">
<span class="sig-prename descclassname"><span class="pre">QNPy.PREDICTION_onePDF_original_mjd.</span></span><span class="sig-name descname"><span class="pre">plot_val_light_curves</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">model</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">valLoader</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">criterion</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mseMetric</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">plot_function2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">device</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tr</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#QNPy.PREDICTION_onePDF_original_mjd.plot_val_light_curves" title="Permalink to this definition"></a></dt>
<dd><p>– Ploting the light curves from val set in original mjd range</p>
<p>Args:
:param model: Deterministic model
:param valLoader: Uploaded val data
:param criterion: criterion
:param mseMetric: Mse Metric
:param plot_function: plot function defined above
:param device: torch device CPU or CUDA
:param tr: trcoeff from pickle file</p>
<p>How to use: valMetrics=plot_val_light_curves(model, valLoader, criterion, mseMetric, plot_function2, device,tr)</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="QNPy.PREDICTION_onePDF_original_mjd.remove_padded_values_and_filter">
<span class="sig-prename descclassname"><span class="pre">QNPy.PREDICTION_onePDF_original_mjd.</span></span><span class="sig-name descname"><span class="pre">remove_padded_values_and_filter</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">folder_path</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#QNPy.PREDICTION_onePDF_original_mjd.remove_padded_values_and_filter" title="Permalink to this definition"></a></dt>
<dd><p>– Preparing data for plotting. It’ll remove the padded values from lc and it’ll delete artifitially added lc with plus and minus errors. If your lc are not padded it’ll only delete additional curves</p>
<dl>
<dt>Args:</dt><dd><dl class="field-list simple">
<dt class="field-odd">param str folder_path<span class="colon">:</span></dt>
<dd class="field-odd"><p>Path to folder where the curves are. In this case it’ll be ‘./dataset/test’ or ‘./dataset/train’ or ‘./dataset/val’</p>
</dd>
</dl>
</dd>
<dt>How to use: </dt><dd><p>folder_path = “./dataset/test”  # Change this to your dataset folder</p>
<p>remove_padded_values_and_filter(folder_path)</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="QNPy.PREDICTION_onePDF_original_mjd.save_test_metrics">
<span class="sig-prename descclassname"><span class="pre">QNPy.PREDICTION_onePDF_original_mjd.</span></span><span class="sig-name descname"><span class="pre">save_test_metrics</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">output_path</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">test_metrics</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#QNPy.PREDICTION_onePDF_original_mjd.save_test_metrics" title="Permalink to this definition"></a></dt>
<dd><p>– saving the test metrics as json file</p>
<p>Args:
:param str OUTPUT_PATH: path to output folder
testMetrics: returned data from ploting function</p>
<p>How to use: save_test_metrics(OUTPUT_PATH, testMetrics)</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="QNPy.PREDICTION_onePDF_original_mjd.save_train_metrics">
<span class="sig-prename descclassname"><span class="pre">QNPy.PREDICTION_onePDF_original_mjd.</span></span><span class="sig-name descname"><span class="pre">save_train_metrics</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">output_path</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">train_metrics</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#QNPy.PREDICTION_onePDF_original_mjd.save_train_metrics" title="Permalink to this definition"></a></dt>
<dd><p>– saving the train metrics as json file</p>
<p>Args:
:param str OUTPUT_PATH: path to output folder
:param trainMetrics: returned data from ploting function</p>
<p>How to use: save_train_metrics(OUTPUT_PATH, trainMetrics)</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="QNPy.PREDICTION_onePDF_original_mjd.save_val_metrics">
<span class="sig-prename descclassname"><span class="pre">QNPy.PREDICTION_onePDF_original_mjd.</span></span><span class="sig-name descname"><span class="pre">save_val_metrics</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">output_path</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">val_metrics</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#QNPy.PREDICTION_onePDF_original_mjd.save_val_metrics" title="Permalink to this definition"></a></dt>
<dd><p>– saving the val metrics as json file</p>
<p>Args:
:param str OUTPUT_PATH: path to output folder
:param valMetrics: returned data from ploting function</p>
<p>How to use: save_val_metrics(OUTPUT_PATH, valMetrics)</p>
</dd></dl>

</section>
<section id="module-QNPy.Preprocess">
<span id="qnpy-preprocess-module"></span><h2>QNPy.Preprocess module<a class="headerlink" href="#module-QNPy.Preprocess" title="Permalink to this heading"></a></h2>
<dl class="py function">
<dt class="sig sig-object py" id="QNPy.Preprocess.backward_pad_curves">
<span class="sig-prename descclassname"><span class="pre">QNPy.Preprocess.</span></span><span class="sig-name descname"><span class="pre">backward_pad_curves</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">folder_path</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">output_folder</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">desired_observations</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">100</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#QNPy.Preprocess.backward_pad_curves" title="Permalink to this definition"></a></dt>
<dd><p>Backward padding the light curves with the last observed value for mag and magerr.
If your data contains ‘time’ values it’ll add +1 for padded values,
and if your data contains ‘MJD’ values it will add +0.2</p>
<p>ARGS:
:param str folder_path: The path to a folder containing the .csv files.
:param str output_path: The path to a folder for saving the padded lc.
:param int desired_observations: The number of points that our package is demanding is 100 but it can be more.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>The padded light curves.</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>object</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="QNPy.Preprocess.clean_and_save_outliers">
<span class="sig-prename descclassname"><span class="pre">QNPy.Preprocess.</span></span><span class="sig-name descname"><span class="pre">clean_and_save_outliers</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">input_folder</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">output_folder</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">threshold</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">3.0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#QNPy.Preprocess.clean_and_save_outliers" title="Permalink to this definition"></a></dt>
<dd><p>Clean data in CSV files within the input folder, remove outliers, and save cleaned files in the output folder.</p>
<dl class="simple">
<dt>Parameters:</dt><dd><p>input_folder (str): Path to the folder containing input CSV files.
output_folder (str): Path to the folder where cleaned CSV files will be saved.
threshold (float, optional): Threshold for outlier detection in terms of standard deviations. Default is 3.0.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="QNPy.Preprocess.clean_save_aggregate_data">
<span class="sig-prename descclassname"><span class="pre">QNPy.Preprocess.</span></span><span class="sig-name descname"><span class="pre">clean_save_aggregate_data</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">input_folder</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">output_folder</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">threshold_aggregation</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">5</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">threshold_outliers</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">3.0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#QNPy.Preprocess.clean_save_aggregate_data" title="Permalink to this definition"></a></dt>
<dd><p>Clean data in CSV files within the input folder, remove outliers, aggregate time and fluxes,
and save cleaned files in the output folder.</p>
<dl class="simple">
<dt>Parameters:</dt><dd><p>input_folder (str): Path to the folder containing input CSV files.
output_folder (str): Path to the folder where cleaned CSV files will be saved.
threshold_aggregation (float, optional): Threshold for time aggregation. Default is 5.
threshold_outliers (float, optional): Threshold for outlier detection in terms of standard deviations. Default is 3.0.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="QNPy.Preprocess.transform">
<span class="sig-prename descclassname"><span class="pre">QNPy.Preprocess.</span></span><span class="sig-name descname"><span class="pre">transform</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#QNPy.Preprocess.transform" title="Permalink to this definition"></a></dt>
<dd><p>Transforming data into [-2,2]x[-2,2] range. This function needs to be uploaded before using it.</p>
<p>Args:
:param data: Your data must contain: MJD or time, mag-magnitude, and magerr-magnitude error.
:type data: object</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="QNPy.Preprocess.transform_and_save">
<span class="sig-prename descclassname"><span class="pre">QNPy.Preprocess.</span></span><span class="sig-name descname"><span class="pre">transform_and_save</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">files</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">data_src</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">data_dst</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">transform</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#QNPy.Preprocess.transform_and_save" title="Permalink to this definition"></a></dt>
<dd><p>Transforms and saves a list of CSV files. The function also saves tr coefficients as a pickle file named trcoeff.pickle.</p>
<p>Args:
:param list files: A list of CSV or TXT file names.
:param str DATA_SRC: The path to the folder containing the CSV or TXT files.
:param str DATA_DST: The path to the folder where the transformed CSV or TXT files will be saved.
:param function transform: The transformation function defined previously.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>A list of transformation coefficients for each file, where each element is a list containing the file name and the transformation coefficients Ax, Bx, Ay, and By.</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>list</p>
</dd>
</dl>
</dd></dl>

</section>
<section id="module-QNPy.SPLITTING_AND_TRAINING">
<span id="qnpy-splitting-and-training-module"></span><h2>QNPy.SPLITTING_AND_TRAINING module<a class="headerlink" href="#module-QNPy.SPLITTING_AND_TRAINING" title="Permalink to this heading"></a></h2>
<dl class="py function">
<dt class="sig sig-object py" id="QNPy.SPLITTING_AND_TRAINING.create_model_and_optimizer">
<span class="sig-prename descclassname"><span class="pre">QNPy.SPLITTING_AND_TRAINING.</span></span><span class="sig-name descname"><span class="pre">create_model_and_optimizer</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">device</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#QNPy.SPLITTING_AND_TRAINING.create_model_and_optimizer" title="Permalink to this definition"></a></dt>
<dd><p>–Defines the model as Deterministic Model, optimizer as torch optimizer, criterion as LogProbLoss, mseMetric as MSELoss and maeMetric as MAELoss</p>
<p>How to use: model, optimizer, criterion, mseMetric, maeMetric = create_model_and_optimizer(device)
Device has to be defined before and it can be cuda or cpu</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="QNPy.SPLITTING_AND_TRAINING.create_split_folders">
<span class="sig-prename descclassname"><span class="pre">QNPy.SPLITTING_AND_TRAINING.</span></span><span class="sig-name descname"><span class="pre">create_split_folders</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">train_folder</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'./dataset/train/'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">test_folder</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'./dataset/test/'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">val_folder</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'./dataset/val/'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#QNPy.SPLITTING_AND_TRAINING.create_split_folders" title="Permalink to this definition"></a></dt>
<dd><p>Creates a TRAIN, TEST, and VAL folders in the directory.</p>
<p>Args:
:param str train_folder: Path for saving the train data.
:param str test_folder: Path for test data.
:param str val_folder: Path for validation data.</p>
<p>How to use: create_split_folders(train_folder=’./dataset/train/’, test_folder=’./dataset/test/’, val_folder=’./dataset/val/’)</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="QNPy.SPLITTING_AND_TRAINING.get_data_loaders">
<span class="sig-prename descclassname"><span class="pre">QNPy.SPLITTING_AND_TRAINING.</span></span><span class="sig-name descname"><span class="pre">get_data_loaders</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data_path_train</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">data_path_val</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">batch_size</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#QNPy.SPLITTING_AND_TRAINING.get_data_loaders" title="Permalink to this definition"></a></dt>
<dd><p>Args:
:param str data_path_train: path to train folder
:param str data_path_val: path to val folder
:param batch_size: it is recommended to be 32</p>
<p>How to use: trainLoader, valLoader = get_data_loader(DATA_PATH_TRAIN,BATCH SIZE)</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="QNPy.SPLITTING_AND_TRAINING.plot_loss">
<span class="sig-prename descclassname"><span class="pre">QNPy.SPLITTING_AND_TRAINING.</span></span><span class="sig-name descname"><span class="pre">plot_loss</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">history_loss_train_file</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">history_loss_val_file</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">epoch_counter_train_loss_file</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#QNPy.SPLITTING_AND_TRAINING.plot_loss" title="Permalink to this definition"></a></dt>
<dd><p>– plotting the history losses</p>
<p>Args:
returned data from test_model
How to use:</p>
<p>history_loss_train_file = ‘./history_loss_train.csv’  # Replace with the path to your history_loss_train CSV file
history_loss_val_file = ‘./history_loss_val.csv’  # Replace with the path to your history_loss_val CSV file
epoch_counter_train_loss_file = ‘./epoch_counter_train_loss.csv’  # Replace with the path to your epoch_counter_train_loss CSV file</p>
<p>logprobloss=plot_loss(history_loss_train_file, history_loss_val_file, epoch_counter_train_loss_file)</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="QNPy.SPLITTING_AND_TRAINING.plot_mae">
<span class="sig-prename descclassname"><span class="pre">QNPy.SPLITTING_AND_TRAINING.</span></span><span class="sig-name descname"><span class="pre">plot_mae</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">history_mae_train_file</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">history_mae_val_file</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">epoch_counter_train_mae_file</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#QNPy.SPLITTING_AND_TRAINING.plot_mae" title="Permalink to this definition"></a></dt>
<dd><p>– plotting the mae metric</p>
<p>args:
returned data from test_model
How to use:</p>
<p>history_mae_train_file = ‘./history_mae_train.csv’  # Replace with the path to your history_mae_train CSV file
history_mae_val_file = ‘./history_mae_val.csv’  # Replace with the path to your history_mae_val CSV file
epoch_counter_train_mae_file = ‘./epoch_counter_train_mae.csv’  # Replace with the path to your epoch_counter_train_mae CSV file</p>
<p>maemetric=plot_mae(history_mae_train_file, history_mae_val_file, epoch_counter_train_mae_file)</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="QNPy.SPLITTING_AND_TRAINING.plot_mse">
<span class="sig-prename descclassname"><span class="pre">QNPy.SPLITTING_AND_TRAINING.</span></span><span class="sig-name descname"><span class="pre">plot_mse</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">history_mse_train_file</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">history_mse_val_file</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">epoch_counter_train_mse_file</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#QNPy.SPLITTING_AND_TRAINING.plot_mse" title="Permalink to this definition"></a></dt>
<dd><p>– plotting the mse metric</p>
<p>args:
returned data from test_model
How to use:</p>
<p>history_mse_train_file = ‘./history_mse_train.csv’  # Replace with the path to your history_mse_train CSV file
history_mse_val_file = ‘./history_mse_val.csv’  # Replace with the path to your history_mse_val CSV file
epoch_counter_train_mse_file = ‘./epoch_counter_train_mse.csv’  # Replace with the path to your epoch_counter_train_mse CSV file</p>
<p>msemetric=plot_mse(history_mse_train_file, history_mse_val_file, epoch_counter_train_mse_file)</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="QNPy.SPLITTING_AND_TRAINING.save_lists_to_csv">
<span class="sig-prename descclassname"><span class="pre">QNPy.SPLITTING_AND_TRAINING.</span></span><span class="sig-name descname"><span class="pre">save_lists_to_csv</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">file_names</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lists</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#QNPy.SPLITTING_AND_TRAINING.save_lists_to_csv" title="Permalink to this definition"></a></dt>
<dd><p>–saving the histories to lists</p>
<p>Args:
:param list file_names: A list of file names to be used for saving the data. Each file name corresponds to a specific data list that will be saved in CSV format.
:param list lists: A list of lists containing the data to be saved. Each inner list represents a set of rows to be written to a CSV file.</p>
<p>How to use: 
# Define the file names for saving the lists
file_names = [“history_loss_train.csv”, “history_loss_val.csv”, “history_mse_train.csv”, “history_mse_val.csv”,”history_mae_train.csv”, “history_mae_val.csv”, “epoch_counter_train_loss.csv”, “epoch_counter_train_mse.csv”, “epoch_counter_train_mae.csv”, “epoch_counter_val_loss.csv”,”epoch_counter_val_mse.csv”, “epoch_counter_val_mae.csv”]</p>
<p># Define the lists
lists = [history_loss_train, history_loss_val, history_mse_train, history_mse_val, history_mae_train,
history_mae_val, epoch_counter_train_loss, epoch_counter_train_mse, epoch_counter_train_mae,
epoch_counter_val_loss, epoch_counter_val_mse, epoch_counter_val_mae]</p>
<p>save_list= save_lists_to_csv(file_names, lists)</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="QNPy.SPLITTING_AND_TRAINING.save_model">
<span class="sig-prename descclassname"><span class="pre">QNPy.SPLITTING_AND_TRAINING.</span></span><span class="sig-name descname"><span class="pre">save_model</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">model</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">MODEL_PATH</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#QNPy.SPLITTING_AND_TRAINING.save_model" title="Permalink to this definition"></a></dt>
<dd><p>– saving the model</p>
<p>Args:
model: Deterministic model
:param str MODEL_PATH: output path for saving the model</p>
<p>How to use: save_model(model, MODEL_PATH)</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="QNPy.SPLITTING_AND_TRAINING.smooth">
<span class="sig-prename descclassname"><span class="pre">QNPy.SPLITTING_AND_TRAINING.</span></span><span class="sig-name descname"><span class="pre">smooth</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">scalars</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">weight</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#QNPy.SPLITTING_AND_TRAINING.smooth" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="QNPy.SPLITTING_AND_TRAINING.split_data">
<span class="sig-prename descclassname"><span class="pre">QNPy.SPLITTING_AND_TRAINING.</span></span><span class="sig-name descname"><span class="pre">split_data</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">files</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">DATA_SRC</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">TRAIN_FOLDER</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">TEST_FOLDER</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">VAL_FOLDER</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#QNPy.SPLITTING_AND_TRAINING.split_data" title="Permalink to this definition"></a></dt>
<dd><p>Splits the data into TRAIN, TEST, and VAL folders.</p>
<p>Args:
:param list files: A list of CSV file names.
:param str DATA_SRC: Path to preprocessed data.
:param str TRAIN_FOLDER: Path for saving the train data.
:param str TEST_FOLDER: Path for saving the test data.
:param str VAL_FOLDER: Path for saving the validation data.</p>
<p>How to use: split_data(files, DATA_SRC, TRAIN_FOLDER, TEST_FOLDER, VAL_FOLDER)</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="QNPy.SPLITTING_AND_TRAINING.train_model">
<span class="sig-prename descclassname"><span class="pre">QNPy.SPLITTING_AND_TRAINING.</span></span><span class="sig-name descname"><span class="pre">train_model</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">model</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">trainLoader</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">valLoader</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">criterion</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">optimizer</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">num_runs</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">EPOCHS</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">EARLY_STOPPING_LIMIT</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mseMetric</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">maeMetric</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">device</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#QNPy.SPLITTING_AND_TRAINING.train_model" title="Permalink to this definition"></a></dt>
<dd><p>– Trains the model</p>
<p>Args:
model: Deterministic model
train_loader: train loader
val_loader: validation loader
criterion: criterion
optimizer: torch optimizer
num_runs: The number of trainings 
epochs: epochs for training. This is optional, but minimum of 3000 is recomended
early_stopping_limit: limits the epochs for stopping the training. This is optional but minimum of 1500 is recomended
mse_metric: mse metric
mae_metric: mae metric
device: torch device cpu or cuda</p>
<p>How to use: If you want to save history_loss_train, history_loss_val, history_mse_train and history_mse_val for plotting you train your model like:</p>
<p>history_loss_train, history_loss_val, history_mse_train, history_mse_val, history_mae_train, history_mae_val, epoch_counter_train_loss, epoch_counter_train_mse, epoch_counter_train_mae, epoch_counter_val_loss, epoch_counter_val_mse, epoch_counter_val_mae = st.train_model(model, trainLoader, valLoader, criterion, optimizer, 1, 3000, 1500, mseMetric, maeMetric, device)</p>
</dd></dl>

</section>
<section id="module-QNPy">
<span id="module-contents"></span><h2>Module contents<a class="headerlink" href="#module-QNPy" title="Permalink to this heading"></a></h2>
<div class="toctree-wrapper compound">
</div>
</section>
</section>
<section id="indices-and-tables">
<h1>Indices and tables<a class="headerlink" href="#indices-and-tables" title="Permalink to this heading"></a></h1>
<ul class="simple">
<li><p><a class="reference internal" href="genindex.html"><span class="std std-ref">Index</span></a></p></li>
<li><p><a class="reference internal" href="py-modindex.html"><span class="std std-ref">Module Index</span></a></p></li>
<li><p><a class="reference internal" href="search.html"><span class="std std-ref">Search Page</span></a></p></li>
</ul>
</section>


           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2024, Marina Pavlovic.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>